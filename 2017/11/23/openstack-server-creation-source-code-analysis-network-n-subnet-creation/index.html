<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>OpenStack 虚拟机创建源码分析：创建网络及子网 | Max&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在上一篇博文分析完 Neutron Server 的启动过程后，按原先安排应该是接着分析 L2、L3 等服务(agent)的启动过程，但发现它们的启动过程相对于 Neutron Server 来说要简单的多，也比较类似，再过多阐述有点重复的嫌疑；另外也是为了从实践角度出发，对虚拟机创建过程的情景做一个分析，将 Nova、Glance、Neutron 及 Cinder 模块串联起来，其中夹杂对一些关">
<meta name="keywords" content="OpenStack,Nova,Neutron,网络,Dnsmasq">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenStack 虚拟机创建源码分析：创建网络及子网">
<meta property="og:url" content="http://xiehongfeng100.github.io/2017/11/23/openstack-server-creation-source-code-analysis-network-n-subnet-creation/index.html">
<meta property="og:site_name" content="Max&#39;s Blog">
<meta property="og:description" content="在上一篇博文分析完 Neutron Server 的启动过程后，按原先安排应该是接着分析 L2、L3 等服务(agent)的启动过程，但发现它们的启动过程相对于 Neutron Server 来说要简单的多，也比较类似，再过多阐述有点重复的嫌疑；另外也是为了从实践角度出发，对虚拟机创建过程的情景做一个分析，将 Nova、Glance、Neutron 及 Cinder 模块串联起来，其中夹杂对一些关">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/create-network.png">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/ipam-driver.png">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/ipam-allocate-subnet.png">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/ipam-allocate-ip.png">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/schedule-network.png">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/schedule-network-rpc-overview.png">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/schedule-network-dnsmasq.png">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/ensure-vlan-bridge.png">
<meta property="og:updated_time" content="2019-05-01T06:21:57.249Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenStack 虚拟机创建源码分析：创建网络及子网">
<meta name="twitter:description" content="在上一篇博文分析完 Neutron Server 的启动过程后，按原先安排应该是接着分析 L2、L3 等服务(agent)的启动过程，但发现它们的启动过程相对于 Neutron Server 来说要简单的多，也比较类似，再过多阐述有点重复的嫌疑；另外也是为了从实践角度出发，对虚拟机创建过程的情景做一个分析，将 Nova、Glance、Neutron 及 Cinder 模块串联起来，其中夹杂对一些关">
<meta name="twitter:image" content="http://xiehongfeng100.github.io/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/create-network.png">
  
    <link rel="alternative" href="/atom.xml" title="Max&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="img/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/author.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Max</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Stay hungry, stay foolish.</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/读书">读书</a></li>
				        
							<li><a href="/tags/翻译">翻译</a></li>
				        
							<li><a href="/categories/网络">网络</a></li>
				        
							<li><a href="/categories/并发">并发</a></li>
				        
							<li><a href="/categories/安全">安全</a></li>
				        
							<li><a href="/categories/运维">运维</a></li>
				        
							<li><a href="/categories/数据库">数据库</a></li>
				        
							<li><a href="/categories/云计算">云计算</a></li>
				        
							<li><a href="/categories/编程语言">编程语言</a></li>
				        
							<li><a href="/categories/操作系统">操作系统</a></li>
				        
							<li><a href="/categories/机器学习">机器学习</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/xiehongfeng100" title="github">github</a>
					        
								<a class="linkedin" target="_blank" href="http://cn.linkedin.com/in/xiehongfeng100" title="linkedin">linkedin</a>
					        
								<a class="mail" target="_blank" href="mailto:xiehongfeng100@yeah.net" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/tmp/" style="font-size: 10px;">/tmp</a> <a href="/tags/AT-T/" style="font-size: 10px;">AT&T</a> <a href="/tags/Affin/" style="font-size: 10px;">Affin</a> <a href="/tags/Alembic/" style="font-size: 10px;">Alembic</a> <a href="/tags/B-树/" style="font-size: 10px;">B+ 树</a> <a href="/tags/BIOS/" style="font-size: 10px;">BIOS</a> <a href="/tags/C-C/" style="font-size: 16.36px;">C/C++</a> <a href="/tags/CA/" style="font-size: 10px;">CA</a> <a href="/tags/CBOW/" style="font-size: 10px;">CBOW</a> <a href="/tags/CNN/" style="font-size: 10.91px;">CNN</a> <a href="/tags/DHCP/" style="font-size: 10px;">DHCP</a> <a href="/tags/Decorator/" style="font-size: 10px;">Decorator</a> <a href="/tags/Django/" style="font-size: 10px;">Django</a> <a href="/tags/Dnsmasq/" style="font-size: 10px;">Dnsmasq</a> <a href="/tags/ELF/" style="font-size: 10px;">ELF</a> <a href="/tags/ELK/" style="font-size: 10px;">ELK</a> <a href="/tags/Elasticsearch/" style="font-size: 11.82px;">Elasticsearch</a> <a href="/tags/GCC/" style="font-size: 10px;">GCC</a> <a href="/tags/HBR/" style="font-size: 10px;">HBR</a> <a href="/tags/IO-Multiplexing/" style="font-size: 11.82px;">IO Multiplexing</a> <a href="/tags/IPTables/" style="font-size: 10px;">IPTables</a> <a href="/tags/Immunity-Debugger/" style="font-size: 10px;">Immunity Debugger</a> <a href="/tags/InnoDB/" style="font-size: 10px;">InnoDB</a> <a href="/tags/KD-Tree/" style="font-size: 10.91px;">KD-Tree</a> <a href="/tags/KNN/" style="font-size: 10px;">KNN</a> <a href="/tags/KVM/" style="font-size: 10px;">KVM</a> <a href="/tags/Kali-Linux/" style="font-size: 10px;">Kali Linux</a> <a href="/tags/Keras/" style="font-size: 10px;">Keras</a> <a href="/tags/Keystone/" style="font-size: 13.64px;">Keystone</a> <a href="/tags/Kibana/" style="font-size: 10px;">Kibana</a> <a href="/tags/Lemmatization/" style="font-size: 10px;">Lemmatization</a> <a href="/tags/Libvirt/" style="font-size: 10.91px;">Libvirt</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/LinuxBridge/" style="font-size: 11.82px;">LinuxBridge</a> <a href="/tags/Logging/" style="font-size: 10px;">Logging</a> <a href="/tags/Logstash/" style="font-size: 10px;">Logstash</a> <a href="/tags/MRO/" style="font-size: 10px;">MRO</a> <a href="/tags/Metasploit-Framwork/" style="font-size: 10px;">Metasploit Framwork</a> <a href="/tags/MySQL/" style="font-size: 10.91px;">MySQL</a> <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/Namespace/" style="font-size: 10px;">Namespace</a> <a href="/tags/Neo4J/" style="font-size: 10.91px;">Neo4J</a> <a href="/tags/Neutron/" style="font-size: 13.64px;">Neutron</a> <a href="/tags/Nova/" style="font-size: 14.55px;">Nova</a> <a href="/tags/OpenStack/" style="font-size: 17.27px;">OpenStack</a> <a href="/tags/OpenVSwitch/" style="font-size: 10px;">OpenVSwitch</a> <a href="/tags/PKI/" style="font-size: 10.91px;">PKI</a> <a href="/tags/PasteDeploy/" style="font-size: 10.91px;">PasteDeploy</a> <a href="/tags/Policy/" style="font-size: 10px;">Policy</a> <a href="/tags/Python/" style="font-size: 18.18px;">Python</a> <a href="/tags/QEMU/" style="font-size: 10px;">QEMU</a> <a href="/tags/RBAC/" style="font-size: 10px;">RBAC</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/SQLAlchemy-Migrate/" style="font-size: 10px;">SQLAlchemy-Migrate</a> <a href="/tags/SSL/" style="font-size: 10px;">SSL</a> <a href="/tags/Sigmoid/" style="font-size: 10px;">Sigmoid</a> <a href="/tags/Skip-Gram/" style="font-size: 10px;">Skip-Gram</a> <a href="/tags/Socket/" style="font-size: 10px;">Socket</a> <a href="/tags/Stop-Words/" style="font-size: 10px;">Stop Words</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Tap/" style="font-size: 10.91px;">Tap</a> <a href="/tags/Token/" style="font-size: 11.82px;">Token</a> <a href="/tags/Tokenization/" style="font-size: 10px;">Tokenization</a> <a href="/tags/Trampolining/" style="font-size: 10px;">Trampolining</a> <a href="/tags/Tun/" style="font-size: 10.91px;">Tun</a> <a href="/tags/Tunnel/" style="font-size: 10px;">Tunnel</a> <a href="/tags/UUID/" style="font-size: 10px;">UUID</a> <a href="/tags/VNC/" style="font-size: 10px;">VNC</a> <a href="/tags/VPN/" style="font-size: 10px;">VPN</a> <a href="/tags/Veth/" style="font-size: 11.82px;">Veth</a> <a href="/tags/VirtualBox/" style="font-size: 10px;">VirtualBox</a> <a href="/tags/Vlan/" style="font-size: 10px;">Vlan</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/WSGI/" style="font-size: 13.64px;">WSGI</a> <a href="/tags/Webob/" style="font-size: 10px;">Webob</a> <a href="/tags/Word2Vec/" style="font-size: 10.91px;">Word2Vec</a> <a href="/tags/Yelper/" style="font-size: 15.45px;">Yelper</a> <a href="/tags/bootsect/" style="font-size: 10px;">bootsect</a> <a href="/tags/cookiecutter/" style="font-size: 10px;">cookiecutter</a> <a href="/tags/delete/" style="font-size: 10px;">delete</a> <a href="/tags/dnsmasq/" style="font-size: 10px;">dnsmasq</a> <a href="/tags/entry-points/" style="font-size: 10px;">entry_points</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/fork/" style="font-size: 10px;">fork</a> <a href="/tags/head/" style="font-size: 10px;">head</a> <a href="/tags/inode/" style="font-size: 10px;">inode</a> <a href="/tags/malloc/" style="font-size: 10px;">malloc</a> <a href="/tags/mona/" style="font-size: 10px;">mona</a> <a href="/tags/new/" style="font-size: 10px;">new</a> <a href="/tags/property/" style="font-size: 10px;">property</a> <a href="/tags/read/" style="font-size: 10px;">read</a> <a href="/tags/routes/" style="font-size: 10px;">routes</a> <a href="/tags/select/" style="font-size: 10px;">select</a> <a href="/tags/setup/" style="font-size: 10px;">setup</a> <a href="/tags/setuptools/" style="font-size: 10px;">setuptools</a> <a href="/tags/shell/" style="font-size: 10.91px;">shell</a> <a href="/tags/stevedore/" style="font-size: 10px;">stevedore</a> <a href="/tags/string/" style="font-size: 10px;">string</a> <a href="/tags/tcpdump/" style="font-size: 10px;">tcpdump</a> <a href="/tags/uWSGI/" style="font-size: 10px;">uWSGI</a> <a href="/tags/update-进程/" style="font-size: 10px;">update 进程</a> <a href="/tags/write/" style="font-size: 10px;">write</a> <a href="/tags/wsgiref/" style="font-size: 10px;">wsgiref</a> <a href="/tags/yield/" style="font-size: 14.55px;">yield</a> <a href="/tags/中断/" style="font-size: 10.91px;">中断</a> <a href="/tags/任务调度/" style="font-size: 10px;">任务调度</a> <a href="/tags/传记/" style="font-size: 10.91px;">传记</a> <a href="/tags/信号/" style="font-size: 10px;">信号</a> <a href="/tags/信号量/" style="font-size: 10px;">信号量</a> <a href="/tags/内存对齐/" style="font-size: 10px;">内存对齐</a> <a href="/tags/内存映射-I-O/" style="font-size: 10px;">内存映射 I/O</a> <a href="/tags/内存规划/" style="font-size: 10px;">内存规划</a> <a href="/tags/内核/" style="font-size: 19.09px;">内核</a> <a href="/tags/内核栈/" style="font-size: 10px;">内核栈</a> <a href="/tags/分页/" style="font-size: 10px;">分页</a> <a href="/tags/加密/" style="font-size: 10.91px;">加密</a> <a href="/tags/加载/" style="font-size: 10.91px;">加载</a> <a href="/tags/协程/" style="font-size: 13.64px;">协程</a> <a href="/tags/可执行目标文件/" style="font-size: 10.91px;">可执行目标文件</a> <a href="/tags/可重定位目标文件/" style="font-size: 10px;">可重定位目标文件</a> <a href="/tags/同步/" style="font-size: 10px;">同步</a> <a href="/tags/商业/" style="font-size: 11.82px;">商业</a> <a href="/tags/地心坐标系/" style="font-size: 10px;">地心坐标系</a> <a href="/tags/多线程/" style="font-size: 10.91px;">多线程</a> <a href="/tags/多进程/" style="font-size: 10px;">多进程</a> <a href="/tags/字符串/" style="font-size: 10px;">字符串</a> <a href="/tags/存储器/" style="font-size: 10.91px;">存储器</a> <a href="/tags/宏/" style="font-size: 10px;">宏</a> <a href="/tags/寄存器/" style="font-size: 10px;">寄存器</a> <a href="/tags/开发环境/" style="font-size: 10px;">开发环境</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/异步/" style="font-size: 10px;">异步</a> <a href="/tags/引导块/" style="font-size: 10px;">引导块</a> <a href="/tags/引导程序/" style="font-size: 12.73px;">引导程序</a> <a href="/tags/归一化/" style="font-size: 10px;">归一化</a> <a href="/tags/微处理器/" style="font-size: 13.64px;">微处理器</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/情感分析/" style="font-size: 10px;">情感分析</a> <a href="/tags/扩容/" style="font-size: 10px;">扩容</a> <a href="/tags/指令集/" style="font-size: 10px;">指令集</a> <a href="/tags/指针/" style="font-size: 12.73px;">指针</a> <a href="/tags/数字签名/" style="font-size: 10px;">数字签名</a> <a href="/tags/数字证书/" style="font-size: 10px;">数字证书</a> <a href="/tags/整数/" style="font-size: 10px;">整数</a> <a href="/tags/文件系统/" style="font-size: 12.73px;">文件系统</a> <a href="/tags/时钟/" style="font-size: 10px;">时钟</a> <a href="/tags/时钟中断/" style="font-size: 10px;">时钟中断</a> <a href="/tags/时间衰减函数/" style="font-size: 10px;">时间衰减函数</a> <a href="/tags/权限/" style="font-size: 10px;">权限</a> <a href="/tags/标准输入/" style="font-size: 10px;">标准输入</a> <a href="/tags/标准输出/" style="font-size: 10px;">标准输出</a> <a href="/tags/标准错误输出/" style="font-size: 10px;">标准错误输出</a> <a href="/tags/栈帧/" style="font-size: 10px;">栈帧</a> <a href="/tags/栈溢出/" style="font-size: 10px;">栈溢出</a> <a href="/tags/根设备/" style="font-size: 10px;">根设备</a> <a href="/tags/母板/" style="font-size: 10px;">母板</a> <a href="/tags/汇编/" style="font-size: 10px;">汇编</a> <a href="/tags/浮点数/" style="font-size: 10px;">浮点数</a> <a href="/tags/消息摘要/" style="font-size: 10px;">消息摘要</a> <a href="/tags/特权级/" style="font-size: 10px;">特权级</a> <a href="/tags/环境变量/" style="font-size: 10px;">环境变量</a> <a href="/tags/生成器/" style="font-size: 14.55px;">生成器</a> <a href="/tags/用户栈/" style="font-size: 10px;">用户栈</a> <a href="/tags/相似度/" style="font-size: 10.91px;">相似度</a> <a href="/tags/硬盘/" style="font-size: 12.73px;">硬盘</a> <a href="/tags/硬链接/" style="font-size: 10px;">硬链接</a> <a href="/tags/管道/" style="font-size: 10px;">管道</a> <a href="/tags/系统调用/" style="font-size: 10px;">系统调用</a> <a href="/tags/索引/" style="font-size: 10px;">索引</a> <a href="/tags/缓冲区/" style="font-size: 10.91px;">缓冲区</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/缺页中断/" style="font-size: 10px;">缺页中断</a> <a href="/tags/网络/" style="font-size: 13.64px;">网络</a> <a href="/tags/翻译/" style="font-size: 14.55px;">翻译</a> <a href="/tags/虚拟地址空间/" style="font-size: 10px;">虚拟地址空间</a> <a href="/tags/虚拟盘/" style="font-size: 10px;">虚拟盘</a> <a href="/tags/请求项/" style="font-size: 10px;">请求项</a> <a href="/tags/质数/" style="font-size: 10px;">质数</a> <a href="/tags/超级块/" style="font-size: 10px;">超级块</a> <a href="/tags/软盘/" style="font-size: 10px;">软盘</a> <a href="/tags/软链接/" style="font-size: 10px;">软链接</a> <a href="/tags/进程派生/" style="font-size: 10px;">进程派生</a> <a href="/tags/进程通信/" style="font-size: 10.91px;">进程通信</a> <a href="/tags/迭代器/" style="font-size: 10px;">迭代器</a> <a href="/tags/金融/" style="font-size: 10px;">金融</a> <a href="/tags/阻塞/" style="font-size: 10.91px;">阻塞</a> <a href="/tags/非阻塞/" style="font-size: 10.91px;">非阻塞</a> <a href="/tags/黑客/" style="font-size: 10px;">黑客</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">谢宏峰，毕业于暨南大学（2009 - 2013）、中国科学院（2013 - 2016），现就职于深信服科技，从事 OpenStack 开发。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Max</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/author.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Max</h1>
			</hgroup>
			
			<p class="header-subtitle">Stay hungry, stay foolish.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/读书">读书</a></li>
		        
					<li><a href="/tags/翻译">翻译</a></li>
		        
					<li><a href="/categories/网络">网络</a></li>
		        
					<li><a href="/categories/并发">并发</a></li>
		        
					<li><a href="/categories/安全">安全</a></li>
		        
					<li><a href="/categories/运维">运维</a></li>
		        
					<li><a href="/categories/数据库">数据库</a></li>
		        
					<li><a href="/categories/云计算">云计算</a></li>
		        
					<li><a href="/categories/编程语言">编程语言</a></li>
		        
					<li><a href="/categories/操作系统">操作系统</a></li>
		        
					<li><a href="/categories/机器学习">机器学习</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/xiehongfeng100" title="github">github</a>
			        
						<a class="linkedin" target="_blank" href="http://cn.linkedin.com/in/xiehongfeng100" title="linkedin">linkedin</a>
			        
						<a class="mail" target="_blank" href="mailto:xiehongfeng100@yeah.net" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-openstack-server-creation-source-code-analysis-network-n-subnet-creation" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/23/openstack-server-creation-source-code-analysis-network-n-subnet-creation/" class="article-date">
  	<time datetime="2017-11-22T23:01:16.000Z" itemprop="datePublished">2017-11-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      OpenStack 虚拟机创建源码分析：创建网络及子网
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dnsmasq/">Dnsmasq</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Neutron/">Neutron</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nova/">Nova</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenStack/">OpenStack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/云计算/">云计算</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在上一篇博文分析完 <a href="http://xiehongfeng100.github.io/2017/11/09/openstack-neutron-server-startup/">Neutron Server 的启动过程</a>后，按原先安排应该是接着分析 L2、L3 等服务(agent)的启动过程，但发现它们的启动过程相对于 Neutron Server 来说要简单的多，也比较类似，再过多阐述有点重复的嫌疑；另外也是为了从实践角度出发，对虚拟机创建过程的情景做一个分析，将 Nova、Glance、Neutron 及 Cinder 模块串联起来，其中夹杂对一些关键服务（如 L2、L3）的分析，也不失为一个好的办法。所以，接下来，我们将从虚拟机创建情境入手，一步步来分析涉及的知识点。今天我们先来看下创建虚拟机会用到的网络及子网。</p>
<p>网络及子网在 Neutron 中都属于 Core Resouce，它们的创建入口在 Core Plugin（ML2）中（具体路由分析见上一篇博文 <a href="http://xiehongfeng100.github.io/2017/11/09/openstack-neutron-server-startup/">Neutron Server 的启动过程</a>）。还有一点需要特别注意的是，<code>Core Plugin 中的 Resource CRUD 操作一般都会涉及与 Type driver、Mechanism driver、Extension driver 及 RPC 的交互。</code>接下来对网络及子网的创建也会重点从这 4 点出发来分析。 </p>
<p>开始之前，我们先说一下本文一些<strong>前提条件</strong>：</p>
<ol>
<li>L2 Agent 采用的是 Linux Bridge Agent</li>
<li>新建的（租户）网络的类型为 VLAN（Enable 了 Admin State）</li>
<li>新建（该网络的）子网开启 DHCP，手动设置 CIDR（不从 subnet pool 分配）</li>
<li>其余都采用默认值（Extension driver 默认开启了 port security）</li>
</ol>
<h1 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a><strong>创建网络</strong></h1><p>在 ML2 中，创建网络（create_network 函数）算是最简单的，因为<code>它最主要的事情就是把网络相关信息保存到 Neutron 数据库</code>当中。</p>
<p>下边我们可以从 5 个部分来分析一下：</p>
<ol>
<li>自身(网络)：在 networks 表添加一条记录，记录自己的信息</li>
<li>Type driver：在 networksegments 表添加一条记录，记录该网络的<code>类型信息</code>、<code>segmentation id</code></li>
<li>Mechanism driver: 所调用的 create_network_precommit 和 create_network_postcommit 均是直接返回（pass）</li>
<li>Extension driver: 在 networksecuritybindings 表添加一条记录，记录是否开始 port security（默认开启）</li>
<li>RPC：ML2 中初始化的 DhcpAgentNotifyAPI（参考<a href="http://xiehongfeng100.github.io/2017/11/09/openstack-neutron-server-startup/">上文</a>）订阅（subscribe）了网络创建的事件（AFTER_CREATE，详细参考<a href="http://xiehongfeng100.github.io/2017/11/09/openstack-neutron-server-startup/">上文</a>Callback System），所以在创建网络结束后会轮询调用到 DhcpAgentNotifyAPI 中的 _native_event_send_dhcp_notification 函数，但最后还是直接返回而没有其他操作</li>
</ol>
<a id="more"></a>
<p>具体创建流程可以参考博文 <a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-cn-openstackneutronml2/index.html" target="_blank" rel="noopener">OpenStack Neutron ML2 Deep Dive</a> 中的一张示意图：<br><img src="/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/create-network.png" alt>  </p>
<h1 id="创建子网"><a href="#创建子网" class="headerlink" title="创建子网"></a><strong>创建子网</strong></h1><p>跟创建网络相比，创建子网就要复杂的多了。除了涉及的 Type/Mechanism/Extension 3 个部分基本都是直接返回（pass）外，其余涉及的需要详述的还有：</p>
<ol>
<li>IPAM</li>
<li>Callback System</li>
<li>Network 调度</li>
<li>（DHCP）Port 创建</li>
<li>网络设备（vlan、tap、veth、bridge）</li>
<li>Dnsmasq（配置文件及开启进程）</li>
<li>RPC</li>
</ol>
<p>下边我们一一详述。</p>
<h2 id="IPAM"><a href="#IPAM" class="headerlink" title="IPAM"></a><strong>IPAM</strong></h2><p>IPAM 是 IP Address Management 的缩写，用于 IP/Subnet 的分配（<code>Allocation</code>）。其实，<a href="http://specs.openstack.org/openstack/neutron-specs/specs/kilo/neutron-ipam.html" target="_blank" rel="noopener">官方文档</a>对 IPAM 的描述是 <code>Pluggable</code>，也就是 IPAM 是可插拔的，说白了，IPAM 是要做成支持多个驱动的方式。从配置文件就可以看出来（cfg.CONF.ipam_driver 值默认为 “internal”）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># setup.cfg</span><br><span class="line">neutron.ipam_drivers =</span><br><span class="line">    fake = neutron.tests.unit.ipam.fake_driver:FakeDriver</span><br><span class="line">    internal = neutron.ipam.drivers.neutrondb_ipam.driver:NeutronDbPool</span><br></pre></td></tr></table></figure></p>
<p>通过这种方式，只要符合接口标准，要写一个我们自己的 IP/Subnet 分配策略驱动就很方便了。可扩展性强。</p>
<p>接下来，我们按<a href="http://specs.openstack.org/openstack/neutron-specs/specs/kilo/neutron-ipam.html" target="_blank" rel="noopener">官方文档</a>对 IPAM 进行一个简单介绍（<strong>具体类名有些跟代码中的不一致，看图就可以了</strong>）。</p>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a><strong>代码结构</strong></h3><p>跟很多驱动式代码一样，IPAM 也有一个抽象类（IPAMDriver），定义接口；然后有一个实现抽象类接口的类（NeutronIPAM）。最后 Neutron 通过调用该 NeutronIPAM 来实现对 IP/Subnet 管理。请见下图：<br><img src="/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/ipam-driver.png" alt>  </p>
<h3 id="Subnet（Allocation-Pools）分配"><a href="#Subnet（Allocation-Pools）分配" class="headerlink" title="Subnet（Allocation Pools）分配"></a><strong>Subnet（Allocation Pools）分配</strong></h3><p>由下图可见，Subnet 的分配是要先经过 IPAM 处理，最后才将其返回的 subnet 信息（<code>只取其中的 allocation pools</code>）和用户传入的参数一起写入到 subnet 自身的数据库表（subnets、ipallocationpools）中：<br><img src="/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/ipam-allocate-subnet.png" alt>  </p>
<p>在具体代码中，往数据库写入 Subnet 信息最终会调用到 allocate_subnet 函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/db/ipam_pluggable_backend.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IpamPluggableBackend</span><span class="params">(ipam_backend_mixin.IpamBackendMixin)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allocate_subnet</span><span class="params">(self, context, network, subnet, subnetpool_id)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 1. 根据（用户传入的）参数分配 subnet（包括 allocation pools），</span></span><br><span class="line">        <span class="comment">#    并将这些信息写到数据库中</span></span><br><span class="line">        ipam_subnet = ipam_driver.allocate_subnet(subnet_request)</span><br><span class="line">        <span class="comment"># get updated details with actually allocated subnet</span></span><br><span class="line">        subnet_request = ipam_subnet.get_details()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 根据（用户传入的）参数和 IPAM 返回的信息（只取其中的 allocation pools）</span></span><br><span class="line">        <span class="comment">#    在数据库中写入 subnet 相关的信息</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            subnet = self._save_subnet(context,</span><br><span class="line">                                       network,</span><br><span class="line">                                       self._make_subnet_args(</span><br><span class="line">                                           subnet_request,</span><br><span class="line">                                           subnet,</span><br><span class="line">                                           subnetpool_id),</span><br><span class="line">                                       subnet[<span class="string">'dns_nameservers'</span>],</span><br><span class="line">                                       subnet[<span class="string">'host_routes'</span>],</span><br><span class="line">                                       subnet_request)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_save_subnet</span><span class="params">(self, context,</span></span></span><br><span class="line"><span class="function"><span class="params">                     network,</span></span></span><br><span class="line"><span class="function"><span class="params">                     subnet_args,</span></span></span><br><span class="line"><span class="function"><span class="params">                     dns_nameservers,</span></span></span><br><span class="line"><span class="function"><span class="params">                     host_routes,</span></span></span><br><span class="line"><span class="function"><span class="params">                     subnet_request)</span>:</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存 Subnet 自身信息到数据库</span></span><br><span class="line">        subnet = models_v2.Subnet(**subnet_args)</span><br><span class="line">        segment_id = subnet_args.get(<span class="string">'segment_id'</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            context.session.add(subnet)</span><br><span class="line">            context.session.flush()</span><br><span class="line">            ..</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> validators.is_attr_set(dns_nameservers):</span><br><span class="line">        <span class="keyword">if</span> validators.is_attr_set(host_routes):</span><br><span class="line">        <span class="keyword">if</span> validators.is_attr_set(service_types):</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 只用到了 IPAM 中返回（分配）的 allocation_pools</span></span><br><span class="line">        self.save_allocation_pools(context, subnet,</span><br><span class="line">                                   subnet_request.allocation_pools)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> subnet</span><br></pre></td></tr></table></figure></p>
<p>到这里，我们就很清楚，<code>IPAM 分配 subnet 其实最重要的就是确定 subnet 的可用地址范围（即 allocation pools），而对于其他信息，除了 subnet 自身信息，它都是不处理的（如 dns_nameserver、host_routes）。</code></p>
<h3 id="IP-分配"><a href="#IP-分配" class="headerlink" title="IP 分配"></a><strong>IP 分配</strong></h3><p>由下图可见，IP 的分配是要先经过 IPAM 处理，最后才将其返回的 ip 信息（及 port 信息，稍后分析）写到 subnet 自身的数据库表（ipallocations）中：<br><img src="/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/ipam-allocate-ip.png" alt>  </p>
<h2 id="Network-调度及网络设备创建"><a href="#Network-调度及网络设备创建" class="headerlink" title="Network 调度及网络设备创建"></a><strong>Network 调度及网络设备创建</strong></h2><p>在数据库中创建完 subnet 相关的条目其实只是做了一个记录，并没有实际在宿主机中体现出来。接下来我们重点就在于分析后者。</p>
<h3 id="事件订阅过程说明"><a href="#事件订阅过程说明" class="headerlink" title="事件订阅过程说明"></a><strong>事件订阅过程说明</strong></h3><p>我们再来看一下 subnet 创建的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/plugins/ml2/plugin.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ml2Plugin</span><span class="params">(...)</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">create_subnet</span><span class="params">(self, context, subnet)</span>:</span></span><br><span class="line">        <span class="comment"># 这一步已经完成</span></span><br><span class="line">        result, mech_context = self._create_subnet_db(context, subnet)</span><br><span class="line">        <span class="comment"># 通过 Callback System 调用订阅该资源（SUBNET）该事件（AFTER_CREATE）的函数</span></span><br><span class="line">        kwargs = &#123;<span class="string">'context'</span>: context, <span class="string">'subnet'</span>: result&#125;</span><br><span class="line">        registry.notify(resources.SUBNET, events.AFTER_CREATE, self, **kwargs)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>而我们在上一篇博文<a href="http://xiehongfeng100.github.io/2017/11/09/openstack-neutron-server-startup/">Neutron Server 的启动过程</a>有提到在初始化 ML2 的过程当中会初始化 RPC Notifiers：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/plugins/ml2/plugin.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ml2Plugin</span><span class="params">(...)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    @<span class="title">resource_registry</span>.<span class="title">tracked_resources</span><span class="params">(...)</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        self._start_rpc_notifiers()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @log_helpers.log_method_call</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_start_rpc_notifiers</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize RPC notifiers for agents."""</span></span><br><span class="line">        <span class="comment"># 这一句不是我们的重点，不过我们在本小结最后有一个简单备注</span></span><br><span class="line">        self.ovo_notifier = ovo_rpc.OVOServerRpcInterface()</span><br><span class="line">        ...</span><br><span class="line">        self.agent_notifiers[const.AGENT_TYPE_DHCP] = (</span><br><span class="line">            dhcp_rpc_agent_api.DhcpAgentNotifyAPI()</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p>
<p>而在 DhcpAgentNotifyAPI 的初始化中会订阅几个 Core Resources 的事件，下边我们只看一下订阅 AFTER_CREATE 事件的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/api/rpc/agentnotifiers/dhcp_rpc_agent_api.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpAgentNotifyAPI</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""API for plugin to notify DHCP agent.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This class implements the client side of an rpc interface.  The server side</span></span><br><span class="line"><span class="string">    is neutron.agent.dhcp.agent.DhcpAgent.  For more information about changing</span></span><br><span class="line"><span class="string">    rpc interfaces, please see doc/source/devref/rpc_api.rst.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># It seems dhcp agent does not support bulk operation</span></span><br><span class="line">    VALID_RESOURCES = [<span class="string">'network'</span>, <span class="string">'subnet'</span>, <span class="string">'port'</span>]</span><br><span class="line">    VALID_METHOD_NAMES = [...</span><br><span class="line">                          <span class="string">'subnet.create.end'</span>,</span><br><span class="line">                          ...]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, topic=topics.DHCP_AGENT, plugin=None)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> resource <span class="keyword">in</span> (resources.NETWORK, resources.PORT, resources.SUBNET):</span><br><span class="line">            ...</span><br><span class="line">            registry.subscribe(self._native_event_send_dhcp_notification,</span><br><span class="line">                               resource, events.AFTER_CREATE)</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure></p>
<p>也就是说，<code>在 Ml2Plugin::create_subnet 函数中的 registry.notify 动作会最终调用到 DhcpAgentNotifyAPI::_native_event_send_dhcp_notification 函数。</code>下边我们从该函数入手：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/api/rpc/agentnotifiers/dhcp_rpc_agent_api.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpAgentNotifyAPI</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_native_event_send_dhcp_notification</span><span class="params">(self, resource, event, trigger,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             context, **kwargs)</span>:</span></span><br><span class="line">        action = event.replace(<span class="string">'after_'</span>, <span class="string">''</span>)</span><br><span class="line">        ...</span><br><span class="line">        method_name = <span class="string">'.'</span>.join((resource, action, <span class="string">'end'</span>))	<span class="comment"># subnet.create.end</span></span><br><span class="line">        payload = kwargs[resource]</span><br><span class="line">        data = &#123;resource: payload&#125;</span><br><span class="line">        ...</span><br><span class="line">        self.notify(context, data, method_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self, context, data, method_name)</span>:</span></span><br><span class="line">        <span class="comment"># data is &#123;'key' : 'value'&#125; with only one key</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">elif</span> obj_type <span class="keyword">in</span> [<span class="string">'port'</span>, <span class="string">'subnet'</span>] <span class="keyword">and</span> <span class="string">'network_id'</span> <span class="keyword">in</span> obj_value:</span><br><span class="line">            network_id = obj_value[<span class="string">'network_id'</span>]</span><br><span class="line">        ...</span><br><span class="line">        method_name = method_name.replace(<span class="string">"."</span>, <span class="string">"_"</span>)	<span class="comment"># create_subnet_end</span></span><br><span class="line">        <span class="keyword">if</span> ...</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._notify_agents(context, method_name, data, network_id)</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>_notify_agents</code> 函数定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/api/rpc/agentnotifiers/dhcp_rpc_agent_api.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpAgentNotifyAPI</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_notify_agents</span><span class="params">(self, context, method, payload, network_id)</span>:</span></span><br><span class="line">        <span class="string">"""Notify all the agents that are hosting the network."""</span></span><br><span class="line">        <span class="comment"># fanout is required as we do not know who is "listening"</span></span><br><span class="line">        ...</span><br><span class="line">        cast_required = method != <span class="string">'network_create_end'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ...	<span class="comment"># fanout_required is False</span></span><br><span class="line">        <span class="keyword">elif</span> cast_required:</span><br><span class="line">            admin_ctx = (context <span class="keyword">if</span> context.is_admin <span class="keyword">else</span> context.elevated())</span><br><span class="line">            <span class="comment"># 1. 从 Core Plugin(ML2) 获取 network 信息</span></span><br><span class="line">            network = self.plugin.get_network(admin_ctx, network_id)</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment"># 2. 判断 network 已经绑定的 DHCP Agents，此时因为该 network 还未绑定任何 DHCP Agent，返回为空列表</span></span><br><span class="line">            agents = self.plugin.get_dhcp_agents_hosting_networks(</span><br><span class="line">                context, [network_id], hosts=network.get(<span class="string">'candidate_hosts'</span>))</span><br><span class="line">            <span class="comment"># !!!! 3. 调度 network 到 DHCP Agents 上（可以有多个）。这部分是重点，下文我们会详细分析。</span></span><br><span class="line">            schedule_required = (</span><br><span class="line">                method == <span class="string">'subnet_create_end'</span> <span class="keyword">or</span></span><br><span class="line">                ...)</span><br><span class="line">            <span class="keyword">if</span> schedule_required:</span><br><span class="line">                agents = self._schedule_network(admin_ctx, network, agents)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> agents:</span><br><span class="line">                ...</span><br><span class="line">            enabled_agents = self._get_enabled_agents(</span><br><span class="line">                context, network, agents, method, payload)</span><br><span class="line">            <span class="comment"># 4. 向每一个 DHCP Agent 发送 RPC 信息。这里不是很重要，我们就不做过多分析了。</span></span><br><span class="line">            <span class="keyword">for</span> agent <span class="keyword">in</span> enabled_agents:</span><br><span class="line">                self._cast_message(</span><br><span class="line">                    context, method, payload, agent.host, agent.topic)</span><br></pre></td></tr></table></figure></p>
<p>这里最终调用的 <code>_notify_agents 函数</code>的重点在<code>Network 调度（如果存在多个 DHCP Agent，确定该网络应该由哪“几”个 DHCP Agent 来服务）</code>（上述代码注释中的第 3 步）。下边我们也就从这步着手。</p>
<hr>
<p><strong>注：</strong>对于 ovo_notifier，在其初始化过程中也会订阅这些 Core Resources 的事件，不过这里不是我们关注的重点，大家简单看下订阅的代码就可以了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/plugins/ml2/ovo_rpc.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OVOServerRpcInterface</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""ML2 server-side RPC interface.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Generates RPC callback notifications on ML2 object changes.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._rpc_pusher = resources_rpc.ResourcesPushRpcApi()</span><br><span class="line">        self._setup_change_handlers()</span><br><span class="line">        LOG.debug(<span class="string">"ML2 OVO RPC backend initialized."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setup_change_handlers</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Setup all of the local callback listeners for resource changes."""</span></span><br><span class="line">        resource_objclass_map = &#123;</span><br><span class="line">            ...</span><br><span class="line">            resources.SUBNET: subnet.Subnet,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        self._resource_handlers = &#123;</span><br><span class="line">            res: _ObjectChangeHandler(res, obj_class, self._rpc_pusher)</span><br><span class="line">            <span class="keyword">for</span> res, obj_class <span class="keyword">in</span> resource_objclass_map.items()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ObjectChangeHandler</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, resource, object_class, resource_push_api)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> (events.AFTER_CREATE, events.AFTER_UPDATE,</span><br><span class="line">                      events.AFTER_DELETE):</span><br><span class="line">            registry.subscribe(self.handle_event, resource, event)</span><br></pre></td></tr></table></figure></p>
<h3 id="Network-调度"><a href="#Network-调度" class="headerlink" title="Network 调度"></a><strong>Network 调度</strong></h3><p>而我们在上一篇博文<a href="http://xiehongfeng100.github.io/2017/11/09/openstack-neutron-server-startup/">Neutron Server 的启动过程</a>有提到在初始化 ML2 的过程当中会初始化 DHCP（的 <code>network_scheduler</code>）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/plugins/ml2/plugin.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ml2Plugin</span><span class="params">(...)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    @<span class="title">resource_registry</span>.<span class="title">tracked_resources</span><span class="params">(...)</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        self._setup_dhcp()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setup_dhcp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize components to support DHCP."""</span></span><br><span class="line">        <span class="comment"># network_scheduler_driver 默认配置为 'neutron.scheduler.dhcp_agent_scheduler.WeightScheduler'</span></span><br><span class="line">        self.network_scheduler = importutils.import_object(</span><br><span class="line">            cfg.CONF.network_scheduler_driver</span><br><span class="line">        )</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>而在 <code>_notify_agents 函数</code> 中，我们先来看 network 调度部分：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/api/rpc/agentnotifiers/dhcp_rpc_agent_api.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpAgentNotifyAPI</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_notify_agents</span><span class="params">(self, context, method, payload, network_id)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> ...</span><br><span class="line">        <span class="keyword">elif</span> cast_required:</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment"># 3. 调度网络到一个 DHCP Agent 上</span></span><br><span class="line">            schedule_required = (</span><br><span class="line">                method == <span class="string">'subnet_create_end'</span> <span class="keyword">or</span></span><br><span class="line">                ...)</span><br><span class="line">            <span class="keyword">if</span> schedule_required:</span><br><span class="line">                agents = self._schedule_network(admin_ctx, network, agents)</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_schedule_network</span><span class="params">(self, context, network, existing_agents)</span>:</span></span><br><span class="line">        <span class="string">"""Schedule the network to new agents</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: all agents associated with the network</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 1. 选择并绑定 DHCP Agents（可以不止一个）</span></span><br><span class="line">        new_agents = self.plugin.schedule_network(context, network) <span class="keyword">or</span> []</span><br><span class="line">        <span class="keyword">if</span> new_agents:</span><br><span class="line">            <span class="comment"># 2. 将 network create 信息通过 RPC 通知每一个 DHCP Agent</span></span><br><span class="line">            <span class="keyword">for</span> agent <span class="keyword">in</span> new_agents:</span><br><span class="line">                self._cast_message(</span><br><span class="line">                    context, <span class="string">'network_create_end'</span>,</span><br><span class="line">                    &#123;<span class="string">'network'</span>: &#123;<span class="string">'id'</span>: network[<span class="string">'id'</span>]&#125;&#125;, agent[<span class="string">'host'</span>])</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>我们先来看 _schedule_network 函数中的第 1 步。</p>
<h4 id="绑定-network-到-DHCP-Agents"><a href="#绑定-network-到-DHCP-Agents" class="headerlink" title="绑定 network 到 DHCP Agents"></a><strong>绑定 network 到 DHCP Agents</strong></h4><p>一图胜千言：<br><img src="/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/schedule-network.png" alt>  </p>
<h4 id="RPC-通知-DHCP-Agent-“network-create”-信息"><a href="#RPC-通知-DHCP-Agent-“network-create”-信息" class="headerlink" title="RPC 通知 DHCP Agent “network create” 信息"></a><strong>RPC 通知 DHCP Agent “network create” 信息</strong></h4><p><strong>注：</strong>因为我们现在所在还是 Neutron Server 的进程，所以要调用 DHCP Agent（进程），需要通过 RPC。</p>
<p>我们先来看一下 RPC 调用概览图：<br><img src="/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/schedule-network-rpc-overview.png" alt>  </p>
<p>下边我们将从上图提到的 <code>DhcpAgent::enable_dhcp_helper</code> 函数的两个点出发来分析。</p>
<p><strong>注：</strong>到这里，我们已经进入 DHCP Agent 进程，与 Neutron Server 的通信就要通过 RPC 了。 </p>
<h5 id="RPC-获取-Core-Plugin-的-network-信息"><a href="#RPC-获取-Core-Plugin-的-network-信息" class="headerlink" title="RPC 获取 Core Plugin 的 network 信息"></a><strong>RPC 获取 Core Plugin 的 network 信息</strong></h5><p>我们现在在 <code>DhcpAgent::enable_dhcp_helper</code> 函数的第 1 步：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/agent/dhcp/agent.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpAgent</span><span class="params">(manager.Manager)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enable_dhcp_helper</span><span class="params">(self, network_id)</span>:</span></span><br><span class="line">        <span class="comment"># 第 1 步</span></span><br><span class="line">        network = self.safe_get_network_info(network_id)</span><br><span class="line">        <span class="keyword">if</span> network:</span><br><span class="line">            <span class="comment"># 第 2 步</span></span><br><span class="line">            self.configure_dhcp_for_network(network)</span><br></pre></td></tr></table></figure></p>
<hr>
<p>在上一篇博文 <a href="http://xiehongfeng100.github.io/2017/11/09/openstack-neutron-server-startup/">Neutron Server 的启动过程</a>中我们有提到在启动 Neutron Server 服务的过程当中，在最终启动服务的时候启动 Core Plugin(ML2) 的 RPC Listener：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/plugins/ml2/plugin.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ml2Plugin</span><span class="params">(...)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @log_helpers.log_method_call</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_rpc_listeners</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Start the RPC loop to let the plugin communicate with agents."""</span></span><br><span class="line">        self._setup_rpc()</span><br><span class="line">        self.topic = topics.PLUGIN	<span class="comment"># 注意监听的 topic</span></span><br><span class="line">        self.conn = n_rpc.create_connection()</span><br><span class="line">        self.conn.create_consumer(self.topic, self.endpoints, fanout=<span class="literal">False</span>)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> self.conn.consume_in_threads()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setup_rpc</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize components to support agent communication."""</span></span><br><span class="line">        self.endpoints = [</span><br><span class="line">            ...</span><br><span class="line">            dhcp_rpc.DhcpRpcCallback(),</span><br><span class="line">            ...</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure></p>
<p>所以，在 <code>DhcpAgent::enable_dhcp_helper</code> 函数通过 RPC 调用 Core Plugin RPC 服务获取 network 信息最终会调用到 <code>dhcp_rpc.DhcpRpcCallback()</code> 这个 Endpoint。我们现在来看一下具体调用过程：<br><strong>1. RPC Client 端</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/agent/dhcp/agent.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpAgent</span><span class="params">(manager.Manager)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enable_dhcp_helper</span><span class="params">(self, network_id)</span>:</span></span><br><span class="line">        network = self.safe_get_network_info(network_id)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">safe_get_network_info</span><span class="params">(self, network_id)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            network = self.plugin_rpc.get_network_info(network_id)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> network:</span><br><span class="line">                LOG.debug(<span class="string">'Network %s has been deleted.'</span>, network_id)</span><br><span class="line">            <span class="keyword">return</span> network</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host=None, conf=None)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        self.plugin_rpc = DhcpPluginApi(topics.PLUGIN, self.conf.host)	<span class="comment"># 注意 client 端的 topic</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>而 <code>get_network_info</code> 函数定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/agent/dhcp/agent.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpPluginApi</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Agent side of the dhcp rpc API.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This class implements the client side of an rpc interface.  The server side</span></span><br><span class="line"><span class="string">    of this interface can be found in</span></span><br><span class="line"><span class="string">    neutron.api.rpc.handlers.dhcp_rpc.DhcpRpcCallback.  For more information</span></span><br><span class="line"><span class="string">    about changing rpc interfaces, see doc/source/devref/rpc_api.rst.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_network_info</span><span class="params">(self, network_id)</span>:</span></span><br><span class="line">        <span class="string">"""Make a remote process call to retrieve network info."""</span></span><br><span class="line">        cctxt = self.client.prepare()</span><br><span class="line">        <span class="comment"># 注意这里是 RPC call 而不是 cast</span></span><br><span class="line">        network = cctxt.call(self.context, <span class="string">'get_network_info'</span>,</span><br><span class="line">                             network_id=network_id, host=self.host)</span><br><span class="line">        <span class="keyword">if</span> network:</span><br><span class="line">            <span class="keyword">return</span> dhcp.NetModel(network)</span><br></pre></td></tr></table></figure></p>
<p><strong>2. RPC Server(Endpoint) 端</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/api/rpc/handlers/dhcp_rpc.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpRpcCallback</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""DHCP agent RPC callback in plugin implementations.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This class implements the server side of an rpc interface.  The client</span></span><br><span class="line"><span class="string">    side of this interface can be found in</span></span><br><span class="line"><span class="string">    neutron.agent.dhcp.agent.DhcpPluginApi.  For more information about</span></span><br><span class="line"><span class="string">    changing rpc interfaces, see doc/source/devref/rpc_api.rst.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_network_info</span><span class="params">(self, context, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Retrieve and return extended information about a network."""</span></span><br><span class="line">        network_id = kwargs.get(<span class="string">'network_id'</span>)</span><br><span class="line">        host = kwargs.get(<span class="string">'host'</span>)</span><br><span class="line">        ...</span><br><span class="line">        plugin = directory.get_plugin()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            network = plugin.get_network(context, network_id)</span><br><span class="line">        ...</span><br><span class="line">        filters = dict(network_id=[network_id])</span><br><span class="line">        subnets = plugin.get_subnets(context, filters=filters)</span><br><span class="line">        ...</span><br><span class="line">        network[<span class="string">'subnets'</span>] = sorted(subnets, key=operator.itemgetter(<span class="string">'id'</span>))</span><br><span class="line">        network[<span class="string">'ports'</span>] = plugin.get_ports(context, filters=filters)</span><br><span class="line">        <span class="keyword">return</span> network</span><br></pre></td></tr></table></figure></p>
<h5 id="DHCP-服务建立过程"><a href="#DHCP-服务建立过程" class="headerlink" title="DHCP 服务建立过程"></a><strong>DHCP 服务建立过程</strong></h5><p><code>DhcpAgent::enable_dhcp_helper</code> 函数的第 2 步就是要为 network 配置 DHCP 了。这部分特别特别重要！代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/agent/dhcp/agent.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpAgent</span><span class="params">(manager.Manager)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enable_dhcp_helper</span><span class="params">(self, network_id)</span>:</span></span><br><span class="line">        <span class="comment"># 第 1 步</span></span><br><span class="line">        network = self.safe_get_network_info(network_id)</span><br><span class="line">        <span class="keyword">if</span> network:</span><br><span class="line">            <span class="comment"># 第 2 步</span></span><br><span class="line">            self.configure_dhcp_for_network(network)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">configure_dhcp_for_network</span><span class="params">(self, network)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> network.admin_state_up:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> subnet <span class="keyword">in</span> network.subnets:</span><br><span class="line">            <span class="keyword">if</span> subnet.enable_dhcp:</span><br><span class="line">                <span class="keyword">if</span> self.call_driver(<span class="string">'enable'</span>, network):</span><br><span class="line">                    self.update_isolated_metadata_proxy(network)</span><br><span class="line">                    self.cache.put(network)</span><br><span class="line">                    <span class="comment"># After enabling dhcp for network, mark all existing</span></span><br><span class="line">                    <span class="comment"># ports as ready. So that the status of ports which are</span></span><br><span class="line">                    <span class="comment"># created before enabling dhcp can be updated.</span></span><br><span class="line">                    self.dhcp_ready_ports |= &#123;p.id <span class="keyword">for</span> p <span class="keyword">in</span> network.ports&#125;</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>而其中的 call_driver 函数定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/agent/dhcp/agent.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpAgent</span><span class="params">(manager.Manager)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_driver</span><span class="params">(self, action, network, **action_kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Invoke an action on a DHCP driver instance."""</span></span><br><span class="line">        LOG.debug(<span class="string">'Calling driver for network: %(net)s action: %(action)s'</span>,</span><br><span class="line">                  &#123;<span class="string">'net'</span>: network.id, <span class="string">'action'</span>: action&#125;)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># the Driver expects something that is duck typed similar to</span></span><br><span class="line">            <span class="comment"># the base models.</span></span><br><span class="line">            <span class="comment"># 1. 初始化 neutron.agent.linux.dhcp.Dnsmasq</span></span><br><span class="line">            <span class="comment"># 这里要特别注意，每次都会为每个 network 的 "New" DHCP Agent 新初始化一次 Dnsmasq 类，</span></span><br><span class="line">            <span class="comment"># 也就是说，对于每一个 "network-dhcpagent" 关系而言，它都会对应一个"独立"的 Dnsmasq 实例，</span></span><br><span class="line">            <span class="comment"># 这样一来，针对该实例而作的配置（如每个 network 的 DHCP 配置目录都是独一无二的</span></span><br><span class="line">            <span class="comment"># /opt/stack/data/neutron/dhcp/network.id）也都是独立于其他实例的</span></span><br><span class="line">            driver = self.dhcp_driver_cls(self.conf,</span><br><span class="line">                                          network,</span><br><span class="line">                                          self._process_monitor,</span><br><span class="line">                                          self.dhcp_version,</span><br><span class="line">                                          self.plugin_rpc)</span><br><span class="line">            <span class="comment"># 2. 调用 neutron.agent.linux.dhcp.Dnsmasq 的 enable 函数</span></span><br><span class="line">            getattr(driver, action)(**action_kwargs)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host=None, conf=None)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># dhcp_driver 的默认值为 neutron.agent.linux.dhcp.Dnsmasq</span></span><br><span class="line">        self.dhcp_driver_cls = importutils.import_class(self.conf.dhcp_driver)</span><br><span class="line">        self.plugin_rpc = DhcpPluginApi(topics.PLUGIN, self.conf.host)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>对于 <code>DhcpAgent::call_driver</code> 函数我们也要分两步来看。</p>
<hr>
<p><strong>1. 初始化 neutron.agent.linux.dhcp::Dnsmasq</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/agent/linux/dhcp.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dnsmasq</span><span class="params">(DhcpLocalProcess)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@six.add_metaclass(abc.ABCMeta)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpLocalProcess</span><span class="params">(DhcpBase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, conf, network, process_monitor, version=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 plugin=None)</span>:</span></span><br><span class="line">        super(DhcpLocalProcess, self).__init__(conf, network, process_monitor,</span><br><span class="line">                                               version, plugin)</span><br><span class="line">        self.confs_dir = self.get_confs_dir(conf)	<span class="comment"># 值为 /opt/stack/data/neutron/dhcp</span></span><br><span class="line">        self.network_conf_dir = os.path.join(self.confs_dir, network.id) <span class="comment"># 值为 self.confs_dir/network.id</span></span><br><span class="line">        fileutils.ensure_tree(self.network_conf_dir, mode=<span class="number">0o755</span>) <span class="comment"># 创建目录 self.confs_dir/network.id</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@six.add_metaclass(abc.ABCMeta)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpBase</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, conf, network, process_monitor,</span></span></span><br><span class="line"><span class="function"><span class="params">                 version=None, plugin=None)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 注意：这里的 plugin 是 `DhcpAgent::call_driver` 函数中传入的</span></span><br><span class="line">        <span class="comment">#      DhcpPluginApi(topics.PLUGIN, self.conf.host)，别误解为 Core Plugin</span></span><br><span class="line">        self.device_manager = DeviceManager(self.conf, plugin)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>要特别注意上边初始化的 <code>self.device_manager</code>。</p>
<hr>
<p><strong>2. 调用 neutron.agent.linux.dhcp::Dnsmasq 的 enable 函数</strong><br>这一步是重中之重，该函数主要做了一下事情：<br><strong>1）</strong>初始化 DHCP 相关设备<br>   <em>A）</em>创建一个 DHCP Port（这部分涉及到 Port 的创建，放到本文最后分析）<br>   <em>B）</em>添加 DHCP namespace 及在该 namespace 添加 lo 网卡<br>   <em>C）</em>在宿主机 root namespace 和 DHCP namespace 之间添加一个 Veth Pair；该 Veth 两端网卡分别是 tapXXX 及 ns-XXX（XXX 表示 Port.id 的前 11 位）<br>   <em>D）</em>Metadata（这里暂未开启，后续博文再分析） 及默认路由设置<br><strong>2）</strong>初始化 DHCP 相关配置文件及启动 Dnsmasq 服务<br>   <em>A）</em>生成 DHCP 相关配置文件：leases、host、addn_hosts、opts 文件<br>   <em>B）</em>启动 Dnsmasq 进程</p>
<p>我们会用一个 UML 图来做说明：<br><img src="/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/schedule-network-dnsmasq.png" alt>  </p>
<p>最后启动起来的 Dnsmasq 的进程（样例）我们可以用 ps -elf 命令看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack@ubuntu-controller:~$ ps -elf | grep dnsmasq</span><br><span class="line">5 S nobody   26045     1  0  80   0 -  7056 -      17:40 ?        00:00:00 dnsmasq --no-hosts  --strict-order --except-interface=lo --pid-file=/opt/stack/data/neutron/dhcp/e99e9fa4-1cd8-4ceb-8f39-1f3e5659461a/pid --dhcp-hostsfile=/opt/stack/data/neutron/dhcp/e99e9fa4-1cd8-4ceb-8f39-1f3e5659461a/host --addn-hosts=/opt/stack/data/neutron/dhcp/e99e9fa4-1cd8-4ceb-8f39-1f3e5659461a/addn_hosts --dhcp-optsfile=/opt/stack/data/neutron/dhcp/e99e9fa4-1cd8-4ceb-8f39-1f3e5659461a/opts --dhcp-leasefile=/opt/stack/data/neutron/dhcp/e99e9fa4-1cd8-4ceb-8f39-1f3e5659461a/leases --dhcp-match=set:ipxe,175 --bind-interfaces --interface=ns-2d01c8ce-ee --dhcp-range=set:tag0,172.16.101.0,static,86400s --dhcp-option-force=option:mtu,1500 --dhcp-lease-max=256 --conf-file= --domain=openstacklocal</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>该 Dnsmasq 进程正在监听的 interface 正是 DHCP namespace 中的 interface ns-XXX。</code></p>
<hr>
<h4 id="Bridge-初始化"><a href="#Bridge-初始化" class="headerlink" title="Bridge 初始化"></a><strong>Bridge 初始化</strong></h4><p>在前面，DHCP 相关的 namespace、ns-XXX、tapXXX 设备已经建立完毕，但 DHCP 现在还不能正常工作，因为还差一个（Linux）Bridge。</p>
<p>关于 Brige 创建的代码隐藏的比较深。如果我们不考虑太多细节的话，Bridge 创建的代码流程如下：</p>
<p><strong>1. </strong>Linux Brige Agent 启动之后会进入一个死循环，不断扫描系统中设备的变化，例如刚刚新建的 DHCP tapXXX 设备：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/plugins/ml2/drivers/agent/_common_agent.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonAgentLoop</span><span class="params">(service.Service)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">daemon_loop</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ...</span><br><span class="line">            device_info = self.scan_devices(previous=device_info, sync=sync)</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (self._device_info_has_changes(device_info)</span><br><span class="line">                <span class="keyword">or</span> ...):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    sync = self.process_network_devices(device_info)</span><br><span class="line">                ...</span><br></pre></td></tr></table></figure></p>
<p><strong>2. </strong>根据是否新增或更新设备，进行下一步操作。此时是新增了 tapXXX 设备：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/plugins/ml2/drivers/agent/_common_agent.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonAgentLoop</span><span class="params">(service.Service)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_network_devices</span><span class="params">(self, device_info)</span>:</span></span><br><span class="line">        <span class="comment"># 此时 device_info 内容为：</span></span><br><span class="line">        <span class="comment">#   &#123;'current': set([...]), 'timestamps': &#123;...&#125;,</span></span><br><span class="line">        <span class="comment">#    'removed': set([]), 'added': set(['tapXXX']), 'updated': set([])&#125;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 关于 Security Group，对于 DHCP Port 而言，它不会为其添加各种防火墙规则，</span></span><br><span class="line">        <span class="comment"># 因为 SG 是用来保护虚拟机的，只会针对虚拟机的 Port 添加防火墙规则。</span></span><br><span class="line">        <span class="comment"># !!! 这部分我们放到 plug 虚拟机的 Port 的时候再讲。</span></span><br><span class="line">        self.sg_agent.setup_port_filters(device_info.get(<span class="string">'added'</span>),</span><br><span class="line">                                         device_info.get(<span class="string">'updated'</span>))</span><br><span class="line">        <span class="comment"># Updated devices are processed the same as new ones, as their</span></span><br><span class="line">        <span class="comment"># admin_state_up may have changed. The set union prevents duplicating</span></span><br><span class="line">        <span class="comment"># work when a device is new and updated in the same polling iteration.</span></span><br><span class="line">        devices_added_updated = (set(device_info.get(<span class="string">'added'</span>))</span><br><span class="line">                                 | set(device_info.get(<span class="string">'updated'</span>)))</span><br><span class="line">        <span class="keyword">if</span> devices_added_updated:</span><br><span class="line">            resync_a = self.treat_devices_added_updated(devices_added_updated)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p><strong>3. </strong>RPC call 到 ML2 获取设备信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/plugins/ml2/drivers/agent/_common_agent.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonAgentLoop</span><span class="params">(service.Service)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treat_devices_added_updated</span><span class="params">(self, devices)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            devices_details_list = self.plugin_rpc.get_devices_details_list(</span><br><span class="line">                self.context, devices, self.agent_id, host=cfg.CONF.host)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> device_details <span class="keyword">in</span> devices_details_list:</span><br><span class="line">            self._process_device_if_exists(device_details)	<span class="comment"># 看下一步</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># device_details 的一个内容样例如下：</span></span><br><span class="line"><span class="comment"># [&#123;</span></span><br><span class="line"><span class="comment"># 	'profile': &#123;</span></span><br><span class="line"><span class="comment"># 	&#125;,</span></span><br><span class="line"><span class="comment"># 	'network_qos_policy_id': None,</span></span><br><span class="line"><span class="comment"># 	'qos_policy_id': None,</span></span><br><span class="line"><span class="comment"># 	'allowed_address_pairs': [],</span></span><br><span class="line"><span class="comment"># 	'admin_state_up': True,</span></span><br><span class="line"><span class="comment"># 	'network_id': '9595178d-0bb5-4af4-9250-6b7d1982ddc9',</span></span><br><span class="line"><span class="comment"># 	'segmentation_id': 100,</span></span><br><span class="line"><span class="comment"># 	'mt': 1500,</span></span><br><span class="line"><span class="comment"># 	'device_owner': 'network: dhcp',</span></span><br><span class="line"><span class="comment"># 	'physical_network': 'default',</span></span><br><span class="line"><span class="comment"># 	'mac_address': 'fa: 16: 3e: b4: 69: dd',</span></span><br><span class="line"><span class="comment"># 	'device': 'tap4faba9e5-ed',	# DHCP tapXXX</span></span><br><span class="line"><span class="comment"># 	'port_security_enabled': False,</span></span><br><span class="line"><span class="comment"># 	'port_id': '4faba9e5-ed08-4ee1-a97b-bb656194e9a6',</span></span><br><span class="line"><span class="comment"># 	'fixed_ips': [&#123;</span></span><br><span class="line"><span class="comment"># 		'subnet_id': '54e3c7e9-71fd-4e02-b397-f9989bc73a6f',</span></span><br><span class="line"><span class="comment"># 		'ip_address': '172.16.100.2'</span></span><br><span class="line"><span class="comment"># 	&#125;],</span></span><br><span class="line"><span class="comment"># 	'network_type': 'vlan'</span></span><br><span class="line"><span class="comment"># &#125;]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4. </strong>创建 Vlan interface/Bridge，并添加 Vlan interface/tapXXX 到 Bridge<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/plugins/ml2/drivers/agent/_common_agent.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonAgentLoop</span><span class="params">(service.Service)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_process_device_if_exists</span><span class="params">(self, device_details)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        device = device_details[<span class="string">'device'</span>]</span><br><span class="line">        <span class="keyword">with</span> self._ignore_missing_device_exceptions(device):</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'port_id'</span> <span class="keyword">in</span> device_details:</span><br><span class="line">                ...</span><br><span class="line">                segment = amb.NetworkSegment(</span><br><span class="line">                    device_details.get(<span class="string">'network_type'</span>),</span><br><span class="line">                    device_details[<span class="string">'physical_network'</span>],</span><br><span class="line">                    device_details.get(<span class="string">'segmentation_id'</span>),</span><br><span class="line">                    device_details.get(<span class="string">'mtu'</span>)</span><br><span class="line">                )</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment"># !!! 重点，下文 UML 图将详述</span></span><br><span class="line">                interface_plugged = self.mgr.plug_interface(</span><br><span class="line">                    network_id, segment,</span><br><span class="line">                    device, device_details[<span class="string">'device_owner'</span>]) <span class="comment"># device_owner 为 'network: dhcp'</span></span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                <span class="comment"># 在前文创建 DHCP port 的时候（DeviceManager::_setup_new_dhcp_port），</span></span><br><span class="line">                <span class="comment"># 数据库中写入的 port 的 admin_state_up 就是为 True（注意跟 network 的</span></span><br><span class="line">                <span class="comment"># admin_state_up 区分开来）</span></span><br><span class="line">                <span class="keyword">if</span> interface_plugged:</span><br><span class="line">                    <span class="comment"># 实际执行 ip link set tapXXX up/down</span></span><br><span class="line">                    self.mgr.ensure_port_admin_state(</span><br><span class="line">                        device, device_details[<span class="string">'admin_state_up'</span>])</span><br><span class="line">                <span class="comment"># update plugin about port status if admin_state is up</span></span><br><span class="line">                <span class="keyword">if</span> device_details[<span class="string">'admin_state_up'</span>]:</span><br><span class="line">                    <span class="keyword">if</span> interface_plugged:</span><br><span class="line">                        self.plugin_rpc.update_device_up(...)</span><br><span class="line">                    ...</span><br></pre></td></tr></table></figure></p>
<p>接下来的 <strong>LinuxBridgeManager::plug_interface</strong> 函数调用就进入到 neutron.plugins.ml2.drivers.linuxbridge.agent.linuxbridge_neutron_agent::LinuxBridgeManager 这个类了，详细操作过程请见下图：<br><img src="/images/cloud-computation/openstack/server-creation-source-code-analysis/network-n-subnet-creation/ensure-vlan-bridge.png" alt>  </p>
<h1 id="创建（DHCP）Port"><a href="#创建（DHCP）Port" class="headerlink" title="创建（DHCP）Port"></a><strong>创建（DHCP）Port</strong></h1><p>在前边小节“2.2.2.2.2 DHCP 服务建立过程”部分提到的 neutron.agent.linux.dhcp::Dnsmasq::enable 函数首先做的就是通过 RPC Call 调用 Core Plugin 的 RPC Endpoint <code>neutron.api.rpc.handlers.dhcp_rpc::DhcpRpcCallback</code> 的 <code>create_dhcp_port</code> 函数来创建一个 DHCP Port。</p>
<p>这里之所以将 DHCP Port 的创建过程单独拿出来分析，主要是因为 DHCP Port 跟一般的 Port 本质上只在于 device_owner 不一样，所以将其单独抽取出来我们可以借此分析一下 Port 的创建过程；另外，Port 本身是一种 Core Resource（同 Network、Subnet），所以有必要单独拿出来说。</p>
<p>我们先来看一下 <code>DhcpRpcCallback::create_dhcp_port</code> 函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/api/rpc/handlers/dhcp_rpc.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DhcpRpcCallback</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_dhcp_port</span><span class="params">(self, context, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Create and return dhcp port information.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ...</span><br><span class="line">        port[<span class="string">'port'</span>][<span class="string">'device_owner'</span>] = constants.DEVICE_OWNER_DHCP	<span class="comment"># "network:dhcp"</span></span><br><span class="line">        ...</span><br><span class="line">        plugin = directory.get_plugin()	<span class="comment"># Core Plugin (ML2)</span></span><br><span class="line">        <span class="keyword">return</span> self._port_action(plugin, context, port, <span class="string">'create_port'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_port_action</span><span class="params">(self, plugin, context, port, action)</span>:</span></span><br><span class="line">        <span class="string">"""Perform port operations taking care of concurrency issues."""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">'create_port'</span>:</span><br><span class="line">                <span class="keyword">return</span> p_utils.create_port(plugin, context, port)</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># neutron/plugins/common/utils.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_port</span><span class="params">(core_plugin, context, port, check_allow_post=True)</span>:</span></span><br><span class="line">    port_data = _fixup_res_dict(context, attributes.PORTS,</span><br><span class="line">                                port.get(<span class="string">'port'</span>, &#123;&#125;),</span><br><span class="line">                                check_allow_post=check_allow_post)</span><br><span class="line">    <span class="comment"># 从这里我们就直接进入 Core Plugin (ML2) 的 Port（“标准”）创建过程</span></span><br><span class="line">    <span class="keyword">return</span> core_plugin.create_port(context, &#123;<span class="string">'port'</span>: port_data&#125;)</span><br></pre></td></tr></table></figure></p>
<p>最终调用的还是 <code>Ml2Plugin::create_port</code> 函数定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/plugins/ml2/plugin.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ml2Plugin</span><span class="params">(...)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_port</span><span class="params">(self, context, port)</span>:</span></span><br><span class="line">        <span class="comment"># 1. 在数据库中创建相关条目</span></span><br><span class="line">        result, mech_context = self._create_port_db(context, port)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 调用注册事件回调函数</span></span><br><span class="line">        <span class="comment"># notify any plugin that is interested in port create events</span></span><br><span class="line">        kwargs = &#123;<span class="string">'context'</span>: context, <span class="string">'port'</span>: result&#125;</span><br><span class="line">        registry.notify(resources.PORT, events.AFTER_CREATE, self, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.mechanism_manager.create_port_postcommit(mech_context)</span><br><span class="line">        <span class="keyword">except</span> ml2_exc.MechanismDriverError:</span><br><span class="line">            <span class="keyword">with</span> excutils.save_and_reraise_exception():</span><br><span class="line">                LOG.error(_LE(<span class="string">"mechanism_manager.create_port_postcommit "</span></span><br><span class="line">                              <span class="string">"failed, deleting port '%s'"</span>), result[<span class="string">'id'</span>])</span><br><span class="line">                self.delete_port(context, result[<span class="string">'id'</span>], l3_port_check=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. Security Group 更新</span></span><br><span class="line">        <span class="comment"># REVISIT(rkukura): Is there any point in calling this before</span></span><br><span class="line">        <span class="comment"># a binding has been successfully established?</span></span><br><span class="line">        self.notify_security_groups_member_updated(context, result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 只是对第 1 步已写入 ml2_port_bindings 的条目进行更新（添加 vif_type、vif_details）</span></span><br><span class="line">            bound_context = self._bind_port_if_needed(mech_context)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bound_context.current</span><br></pre></td></tr></table></figure></p>
<p>下边我们就按代码注释中的 3 步来对该函数进行分析。</p>
<p><strong>1. 数据库条目创建</strong><br><code>Ml2Plugin::create_port</code> 函数会在一下这些数据表中写入条目：</p>
<ul>
<li>在 ports 表添加新 port 的信息条目（id 及 mac 地址在自动生成，除非有作为创建参数传入）</li>
<li>利用 <code>IPAM</code>（这部分我们在前文 IPAM 处已经有介绍） 为该 port 分配 IP 地址（除非有作为创建参数传入），并在 ipamallocations 表添加该 IP 信息条目，之后再在 ipallocations 表该 IP 信息条目（跟 ipamallocations 表的稍有不同）</li>
<li>在 portsecuritybindings 表添加一个条目</li>
<li>在 ml2_port_bindings 表添加一个条目</li>
</ul>
<p><strong>2. 调用注册事件回调函数</strong><br>在前边 “2.2.1 事件订阅过程说明”中，我们提到了类 <code>dhcp_rpc_agent_api::DhcpAgentNotifyAPI</code> 在初始化的时候会订阅 Core Resources 的 AFTER_CREATE 事件，所以，当在数据库中创建完 Port 及相关信息条目后，就会调用注册的 <code>DhcpAgentNotifyAPI::_native_event_send_dhcp_notification</code> 函数。这次因为 Network 已经调度过了，所以该函数此次没做什么实质性的东西。</p>
<hr>
<p><strong>注：</strong>除了 <code>DhcpAgentNotifyAPI</code> 和 <code>OVOServerRpcInterface</code> 类在初始化的时候会订阅 port 的 AFTER_CREATE 事件之外，Service Plugin <code>neutron.services.l3_router.l3_router_plugin::L3RouterPlugin</code> 在初始化的时候也会订阅该事件（关于 L3 Agent 我们这里暂时不分析，放到后续博文当中）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># neutron/services/l3_router/l3_router_plugin.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">L3RouterPlugin</span><span class="params">(...)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'dvr'</span> <span class="keyword">in</span> self.supported_extension_aliases:</span><br><span class="line">            l3_dvrscheduler_db.subscribe()</span><br><span class="line"></span><br><span class="line"><span class="comment"># neutron/db/l3_dvrscheduler_db.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    registry.subscribe(</span><br><span class="line">        _notify_l3_agent_new_port, resources.PORT, events.AFTER_CREATE)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_notify_l3_agent_new_port</span><span class="params">(resource, event, trigger, **kwargs)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p><strong>3. Security Group 更新</strong><br>self.notify_security_groups_member_updated(context, result) 最终调用的其实是 <code>SecurityGroupAgentRpcCallbackMixin::security_groups_provider_updated</code> 函数，但该函数是一个空（NOOP）函数（可以看一下函数的注释）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityGroupAgentRpcCallbackMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">security_groups_provider_updated</span><span class="params">(self, context, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Callback for security group provider update.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This is now a NOOP since provider rules are static. The server just</span></span><br><span class="line"><span class="string">        generates the notification for agents running older versions that have</span></span><br><span class="line"><span class="string">        IP-specific rules.</span></span><br><span class="line"><span class="string">        """</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/11/openstack-server-creation-source-code-analysis-server-creation-overview-and-preliminary-work/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          OpenStack 虚拟机创建源码分析：虚拟机创建 —— 概览及前期工作
        
      </div>
    </a>
  
  
    <a href="/2017/11/09/openstack-neutron-server-startup/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">OpenStack 源码系列之 Neutron：Neutron Server 启动</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>







      <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>

<script>
var gitalk = new Gitalk({
  clientID: '64c19d7f57bebbb343c4',
  clientSecret: '287daeba39e73fdde92f24540c9f3c0fd5238512',
  repo: 'BlogComments',
  owner: 'xiemax100',
  admin: ['xiemax100'],
  id: md5(window.location.pathname),
  distractionFreeMode: true
})

gitalk.render('gitalk-container')
</script>






    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#创建网络"><span class="toc-number">1.</span> <span class="toc-text">创建网络</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建子网"><span class="toc-number">2.</span> <span class="toc-text">创建子网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IPAM"><span class="toc-number">2.1.</span> <span class="toc-text">IPAM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码结构"><span class="toc-number">2.1.1.</span> <span class="toc-text">代码结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subnet（Allocation-Pools）分配"><span class="toc-number">2.1.2.</span> <span class="toc-text">Subnet（Allocation Pools）分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-分配"><span class="toc-number">2.1.3.</span> <span class="toc-text">IP 分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Network-调度及网络设备创建"><span class="toc-number">2.2.</span> <span class="toc-text">Network 调度及网络设备创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件订阅过程说明"><span class="toc-number">2.2.1.</span> <span class="toc-text">事件订阅过程说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Network-调度"><span class="toc-number">2.2.2.</span> <span class="toc-text">Network 调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#绑定-network-到-DHCP-Agents"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">绑定 network 到 DHCP Agents</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPC-通知-DHCP-Agent-“network-create”-信息"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">RPC 通知 DHCP Agent “network create” 信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RPC-获取-Core-Plugin-的-network-信息"><span class="toc-number">2.2.2.2.1.</span> <span class="toc-text">RPC 获取 Core Plugin 的 network 信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DHCP-服务建立过程"><span class="toc-number">2.2.2.2.2.</span> <span class="toc-text">DHCP 服务建立过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bridge-初始化"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">Bridge 初始化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建（DHCP）Port"><span class="toc-number">3.</span> <span class="toc-text">创建（DHCP）Port</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var toc_button = document.getElementById("tocButton");
    var toc_div = document.getElementById("toc");
    toc_button.onclick=function() {
        if (toc_div.style.display == "none") {
            toc_div.style.display = "block";
            toc_button.value = "隐藏目录";
            document.getElementById("switch-btn").style.display = "none";
            document.getElementById("switch-area").style.display = "none";
        }
        else {
            toc_div.style.display = "none";
            toc_button.value = "显示目录";
            document.getElementById("switch-btn").style.display = "block";
            document.getElementById("switch-area").style.display = "block";
        }
    }

    if ($(".toc").length < 1) {
        $("#toc").css("display","none");
        $("#tocButton").css("display","none");
        $(".switch-btn").css("display","block");
        $(".switch-area").css("display","block");
    }
</script>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 Max
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>