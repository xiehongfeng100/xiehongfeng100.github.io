<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Linux 内核学习笔记：进程 1 的创建及执行（第 3 部分） —— 读取硬盘引导块 | Max&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文接着上一博文 Linux 内核学习笔记：进程 1 创建及执行（第 2 部分）最后的“调用 sys_setup”继续写下去。 调用 sys_setup根据 sys_setup 函数，我们分成几个部分来对其进行解释。 进程 1 设置硬盘的 hd_info阅读这部分，请先参考以下两篇博文有关“硬盘”部分：Linux 内核学习笔记：预备知识之“硬盘基础知识”Linux 内核学习笔记：内核引导程序之“s">
<meta name="keywords" content="Linux,内核,硬盘,引导块">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内核学习笔记：进程 1 的创建及执行（第 3 部分） —— 读取硬盘引导块">
<meta property="og:url" content="http://xiehongfeng100.github.io/2016/02/28/linux-kenel-0-11-topic-process-one-part3/index.html">
<meta property="og:site_name" content="Max&#39;s Blog">
<meta property="og:description" content="本文接着上一博文 Linux 内核学习笔记：进程 1 创建及执行（第 2 部分）最后的“调用 sys_setup”继续写下去。 调用 sys_setup根据 sys_setup 函数，我们分成几个部分来对其进行解释。 进程 1 设置硬盘的 hd_info阅读这部分，请先参考以下两篇博文有关“硬盘”部分：Linux 内核学习笔记：预备知识之“硬盘基础知识”Linux 内核学习笔记：内核引导程序之“s">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/process-one/part3/硬盘上分区.png">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/process-one/part3/bread函数执行流程框图.png">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/process-one/part3/getblk函数执行流程图.png">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/process-one/part3/AT硬盘控制器寄存器端口及作用.png">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/process-one/part3/处理请求项队列的情景.png">
<meta property="og:updated_time" content="2019-05-01T06:53:11.586Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux 内核学习笔记：进程 1 的创建及执行（第 3 部分） —— 读取硬盘引导块">
<meta name="twitter:description" content="本文接着上一博文 Linux 内核学习笔记：进程 1 创建及执行（第 2 部分）最后的“调用 sys_setup”继续写下去。 调用 sys_setup根据 sys_setup 函数，我们分成几个部分来对其进行解释。 进程 1 设置硬盘的 hd_info阅读这部分，请先参考以下两篇博文有关“硬盘”部分：Linux 内核学习笔记：预备知识之“硬盘基础知识”Linux 内核学习笔记：内核引导程序之“s">
<meta name="twitter:image" content="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/process-one/part3/硬盘上分区.png">
  
    <link rel="alternative" href="/atom.xml" title="Max&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="img/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/author.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Max</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Stay hungry, stay foolish.</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/读书">读书</a></li>
				        
							<li><a href="/tags/翻译">翻译</a></li>
				        
							<li><a href="/categories/网络">网络</a></li>
				        
							<li><a href="/categories/并发">并发</a></li>
				        
							<li><a href="/categories/安全">安全</a></li>
				        
							<li><a href="/categories/运维">运维</a></li>
				        
							<li><a href="/categories/数据库">数据库</a></li>
				        
							<li><a href="/categories/云计算">云计算</a></li>
				        
							<li><a href="/categories/编程语言">编程语言</a></li>
				        
							<li><a href="/categories/操作系统">操作系统</a></li>
				        
							<li><a href="/categories/机器学习">机器学习</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/xiehongfeng100" title="github">github</a>
					        
								<a class="linkedin" target="_blank" href="http://cn.linkedin.com/in/xiehongfeng100" title="linkedin">linkedin</a>
					        
								<a class="mail" target="_blank" href="mailto:xiehongfeng100@yeah.net" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/tmp/" style="font-size: 10px;">/tmp</a> <a href="/tags/AT-T/" style="font-size: 10px;">AT&T</a> <a href="/tags/Affin/" style="font-size: 10px;">Affin</a> <a href="/tags/Alembic/" style="font-size: 10px;">Alembic</a> <a href="/tags/B-树/" style="font-size: 10px;">B+ 树</a> <a href="/tags/BIOS/" style="font-size: 10px;">BIOS</a> <a href="/tags/C-C/" style="font-size: 16.36px;">C/C++</a> <a href="/tags/CA/" style="font-size: 10px;">CA</a> <a href="/tags/CBOW/" style="font-size: 10px;">CBOW</a> <a href="/tags/CNN/" style="font-size: 10.91px;">CNN</a> <a href="/tags/DHCP/" style="font-size: 10px;">DHCP</a> <a href="/tags/Decorator/" style="font-size: 10px;">Decorator</a> <a href="/tags/Django/" style="font-size: 10px;">Django</a> <a href="/tags/Dnsmasq/" style="font-size: 10px;">Dnsmasq</a> <a href="/tags/ELF/" style="font-size: 10px;">ELF</a> <a href="/tags/ELK/" style="font-size: 10px;">ELK</a> <a href="/tags/Elasticsearch/" style="font-size: 11.82px;">Elasticsearch</a> <a href="/tags/GCC/" style="font-size: 10px;">GCC</a> <a href="/tags/HBR/" style="font-size: 10px;">HBR</a> <a href="/tags/IO-Multiplexing/" style="font-size: 11.82px;">IO Multiplexing</a> <a href="/tags/IPTables/" style="font-size: 10px;">IPTables</a> <a href="/tags/Immunity-Debugger/" style="font-size: 10px;">Immunity Debugger</a> <a href="/tags/InnoDB/" style="font-size: 10px;">InnoDB</a> <a href="/tags/KD-Tree/" style="font-size: 10.91px;">KD-Tree</a> <a href="/tags/KNN/" style="font-size: 10px;">KNN</a> <a href="/tags/KVM/" style="font-size: 10px;">KVM</a> <a href="/tags/Kali-Linux/" style="font-size: 10px;">Kali Linux</a> <a href="/tags/Keras/" style="font-size: 10px;">Keras</a> <a href="/tags/Keystone/" style="font-size: 13.64px;">Keystone</a> <a href="/tags/Kibana/" style="font-size: 10px;">Kibana</a> <a href="/tags/Lemmatization/" style="font-size: 10px;">Lemmatization</a> <a href="/tags/Libvirt/" style="font-size: 10.91px;">Libvirt</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/LinuxBridge/" style="font-size: 11.82px;">LinuxBridge</a> <a href="/tags/Logging/" style="font-size: 10px;">Logging</a> <a href="/tags/Logstash/" style="font-size: 10px;">Logstash</a> <a href="/tags/MRO/" style="font-size: 10px;">MRO</a> <a href="/tags/Metasploit-Framwork/" style="font-size: 10px;">Metasploit Framwork</a> <a href="/tags/MySQL/" style="font-size: 10.91px;">MySQL</a> <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/Namespace/" style="font-size: 10px;">Namespace</a> <a href="/tags/Neo4J/" style="font-size: 10.91px;">Neo4J</a> <a href="/tags/Neutron/" style="font-size: 13.64px;">Neutron</a> <a href="/tags/Nova/" style="font-size: 14.55px;">Nova</a> <a href="/tags/OpenStack/" style="font-size: 17.27px;">OpenStack</a> <a href="/tags/OpenVSwitch/" style="font-size: 10px;">OpenVSwitch</a> <a href="/tags/PKI/" style="font-size: 10.91px;">PKI</a> <a href="/tags/PasteDeploy/" style="font-size: 10.91px;">PasteDeploy</a> <a href="/tags/Policy/" style="font-size: 10px;">Policy</a> <a href="/tags/Python/" style="font-size: 18.18px;">Python</a> <a href="/tags/QEMU/" style="font-size: 10px;">QEMU</a> <a href="/tags/RBAC/" style="font-size: 10px;">RBAC</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/SQLAlchemy-Migrate/" style="font-size: 10px;">SQLAlchemy-Migrate</a> <a href="/tags/SSL/" style="font-size: 10px;">SSL</a> <a href="/tags/Sigmoid/" style="font-size: 10px;">Sigmoid</a> <a href="/tags/Skip-Gram/" style="font-size: 10px;">Skip-Gram</a> <a href="/tags/Socket/" style="font-size: 10px;">Socket</a> <a href="/tags/Stop-Words/" style="font-size: 10px;">Stop Words</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Tap/" style="font-size: 10.91px;">Tap</a> <a href="/tags/Token/" style="font-size: 11.82px;">Token</a> <a href="/tags/Tokenization/" style="font-size: 10px;">Tokenization</a> <a href="/tags/Trampolining/" style="font-size: 10px;">Trampolining</a> <a href="/tags/Tun/" style="font-size: 10.91px;">Tun</a> <a href="/tags/Tunnel/" style="font-size: 10px;">Tunnel</a> <a href="/tags/UUID/" style="font-size: 10px;">UUID</a> <a href="/tags/VNC/" style="font-size: 10px;">VNC</a> <a href="/tags/VPN/" style="font-size: 10px;">VPN</a> <a href="/tags/Veth/" style="font-size: 11.82px;">Veth</a> <a href="/tags/VirtualBox/" style="font-size: 10px;">VirtualBox</a> <a href="/tags/Vlan/" style="font-size: 10px;">Vlan</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/WSGI/" style="font-size: 13.64px;">WSGI</a> <a href="/tags/Webob/" style="font-size: 10px;">Webob</a> <a href="/tags/Word2Vec/" style="font-size: 10.91px;">Word2Vec</a> <a href="/tags/Yelper/" style="font-size: 15.45px;">Yelper</a> <a href="/tags/bootsect/" style="font-size: 10px;">bootsect</a> <a href="/tags/cookiecutter/" style="font-size: 10px;">cookiecutter</a> <a href="/tags/delete/" style="font-size: 10px;">delete</a> <a href="/tags/dnsmasq/" style="font-size: 10px;">dnsmasq</a> <a href="/tags/entry-points/" style="font-size: 10px;">entry_points</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/fork/" style="font-size: 10px;">fork</a> <a href="/tags/head/" style="font-size: 10px;">head</a> <a href="/tags/inode/" style="font-size: 10px;">inode</a> <a href="/tags/malloc/" style="font-size: 10px;">malloc</a> <a href="/tags/mona/" style="font-size: 10px;">mona</a> <a href="/tags/new/" style="font-size: 10px;">new</a> <a href="/tags/property/" style="font-size: 10px;">property</a> <a href="/tags/read/" style="font-size: 10px;">read</a> <a href="/tags/routes/" style="font-size: 10px;">routes</a> <a href="/tags/select/" style="font-size: 10px;">select</a> <a href="/tags/setup/" style="font-size: 10px;">setup</a> <a href="/tags/setuptools/" style="font-size: 10px;">setuptools</a> <a href="/tags/shell/" style="font-size: 10.91px;">shell</a> <a href="/tags/stevedore/" style="font-size: 10px;">stevedore</a> <a href="/tags/string/" style="font-size: 10px;">string</a> <a href="/tags/tcpdump/" style="font-size: 10px;">tcpdump</a> <a href="/tags/uWSGI/" style="font-size: 10px;">uWSGI</a> <a href="/tags/update-进程/" style="font-size: 10px;">update 进程</a> <a href="/tags/write/" style="font-size: 10px;">write</a> <a href="/tags/wsgiref/" style="font-size: 10px;">wsgiref</a> <a href="/tags/yield/" style="font-size: 14.55px;">yield</a> <a href="/tags/中断/" style="font-size: 10.91px;">中断</a> <a href="/tags/任务调度/" style="font-size: 10px;">任务调度</a> <a href="/tags/传记/" style="font-size: 10.91px;">传记</a> <a href="/tags/信号/" style="font-size: 10px;">信号</a> <a href="/tags/信号量/" style="font-size: 10px;">信号量</a> <a href="/tags/内存对齐/" style="font-size: 10px;">内存对齐</a> <a href="/tags/内存映射-I-O/" style="font-size: 10px;">内存映射 I/O</a> <a href="/tags/内存规划/" style="font-size: 10px;">内存规划</a> <a href="/tags/内核/" style="font-size: 19.09px;">内核</a> <a href="/tags/内核栈/" style="font-size: 10px;">内核栈</a> <a href="/tags/分页/" style="font-size: 10px;">分页</a> <a href="/tags/加密/" style="font-size: 10.91px;">加密</a> <a href="/tags/加载/" style="font-size: 10.91px;">加载</a> <a href="/tags/协程/" style="font-size: 13.64px;">协程</a> <a href="/tags/可执行目标文件/" style="font-size: 10.91px;">可执行目标文件</a> <a href="/tags/可重定位目标文件/" style="font-size: 10px;">可重定位目标文件</a> <a href="/tags/同步/" style="font-size: 10px;">同步</a> <a href="/tags/商业/" style="font-size: 11.82px;">商业</a> <a href="/tags/地心坐标系/" style="font-size: 10px;">地心坐标系</a> <a href="/tags/多线程/" style="font-size: 10.91px;">多线程</a> <a href="/tags/多进程/" style="font-size: 10px;">多进程</a> <a href="/tags/字符串/" style="font-size: 10px;">字符串</a> <a href="/tags/存储器/" style="font-size: 10.91px;">存储器</a> <a href="/tags/宏/" style="font-size: 10px;">宏</a> <a href="/tags/寄存器/" style="font-size: 10px;">寄存器</a> <a href="/tags/开发环境/" style="font-size: 10px;">开发环境</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/异步/" style="font-size: 10px;">异步</a> <a href="/tags/引导块/" style="font-size: 10px;">引导块</a> <a href="/tags/引导程序/" style="font-size: 12.73px;">引导程序</a> <a href="/tags/归一化/" style="font-size: 10px;">归一化</a> <a href="/tags/微处理器/" style="font-size: 13.64px;">微处理器</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/情感分析/" style="font-size: 10px;">情感分析</a> <a href="/tags/扩容/" style="font-size: 10px;">扩容</a> <a href="/tags/指令集/" style="font-size: 10px;">指令集</a> <a href="/tags/指针/" style="font-size: 12.73px;">指针</a> <a href="/tags/数字签名/" style="font-size: 10px;">数字签名</a> <a href="/tags/数字证书/" style="font-size: 10px;">数字证书</a> <a href="/tags/整数/" style="font-size: 10px;">整数</a> <a href="/tags/文件系统/" style="font-size: 12.73px;">文件系统</a> <a href="/tags/时钟/" style="font-size: 10px;">时钟</a> <a href="/tags/时钟中断/" style="font-size: 10px;">时钟中断</a> <a href="/tags/时间衰减函数/" style="font-size: 10px;">时间衰减函数</a> <a href="/tags/权限/" style="font-size: 10px;">权限</a> <a href="/tags/标准输入/" style="font-size: 10px;">标准输入</a> <a href="/tags/标准输出/" style="font-size: 10px;">标准输出</a> <a href="/tags/标准错误输出/" style="font-size: 10px;">标准错误输出</a> <a href="/tags/栈帧/" style="font-size: 10px;">栈帧</a> <a href="/tags/栈溢出/" style="font-size: 10px;">栈溢出</a> <a href="/tags/根设备/" style="font-size: 10px;">根设备</a> <a href="/tags/母板/" style="font-size: 10px;">母板</a> <a href="/tags/汇编/" style="font-size: 10px;">汇编</a> <a href="/tags/浮点数/" style="font-size: 10px;">浮点数</a> <a href="/tags/消息摘要/" style="font-size: 10px;">消息摘要</a> <a href="/tags/特权级/" style="font-size: 10px;">特权级</a> <a href="/tags/环境变量/" style="font-size: 10px;">环境变量</a> <a href="/tags/生成器/" style="font-size: 14.55px;">生成器</a> <a href="/tags/用户栈/" style="font-size: 10px;">用户栈</a> <a href="/tags/相似度/" style="font-size: 10.91px;">相似度</a> <a href="/tags/硬盘/" style="font-size: 12.73px;">硬盘</a> <a href="/tags/硬链接/" style="font-size: 10px;">硬链接</a> <a href="/tags/管道/" style="font-size: 10px;">管道</a> <a href="/tags/系统调用/" style="font-size: 10px;">系统调用</a> <a href="/tags/索引/" style="font-size: 10px;">索引</a> <a href="/tags/缓冲区/" style="font-size: 10.91px;">缓冲区</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/缺页中断/" style="font-size: 10px;">缺页中断</a> <a href="/tags/网络/" style="font-size: 13.64px;">网络</a> <a href="/tags/翻译/" style="font-size: 14.55px;">翻译</a> <a href="/tags/虚拟地址空间/" style="font-size: 10px;">虚拟地址空间</a> <a href="/tags/虚拟盘/" style="font-size: 10px;">虚拟盘</a> <a href="/tags/请求项/" style="font-size: 10px;">请求项</a> <a href="/tags/质数/" style="font-size: 10px;">质数</a> <a href="/tags/超级块/" style="font-size: 10px;">超级块</a> <a href="/tags/软盘/" style="font-size: 10px;">软盘</a> <a href="/tags/软链接/" style="font-size: 10px;">软链接</a> <a href="/tags/进程派生/" style="font-size: 10px;">进程派生</a> <a href="/tags/进程通信/" style="font-size: 10.91px;">进程通信</a> <a href="/tags/迭代器/" style="font-size: 10px;">迭代器</a> <a href="/tags/金融/" style="font-size: 10px;">金融</a> <a href="/tags/阻塞/" style="font-size: 10.91px;">阻塞</a> <a href="/tags/非阻塞/" style="font-size: 10.91px;">非阻塞</a> <a href="/tags/黑客/" style="font-size: 10px;">黑客</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">谢宏峰，毕业于暨南大学（2009 - 2013）、中国科学院（2013 - 2016），现就职于深信服科技，从事 OpenStack 开发。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Max</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/author.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Max</h1>
			</hgroup>
			
			<p class="header-subtitle">Stay hungry, stay foolish.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/读书">读书</a></li>
		        
					<li><a href="/tags/翻译">翻译</a></li>
		        
					<li><a href="/categories/网络">网络</a></li>
		        
					<li><a href="/categories/并发">并发</a></li>
		        
					<li><a href="/categories/安全">安全</a></li>
		        
					<li><a href="/categories/运维">运维</a></li>
		        
					<li><a href="/categories/数据库">数据库</a></li>
		        
					<li><a href="/categories/云计算">云计算</a></li>
		        
					<li><a href="/categories/编程语言">编程语言</a></li>
		        
					<li><a href="/categories/操作系统">操作系统</a></li>
		        
					<li><a href="/categories/机器学习">机器学习</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/xiehongfeng100" title="github">github</a>
			        
						<a class="linkedin" target="_blank" href="http://cn.linkedin.com/in/xiehongfeng100" title="linkedin">linkedin</a>
			        
						<a class="mail" target="_blank" href="mailto:xiehongfeng100@yeah.net" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-linux-kenel-0-11-topic-process-one-part3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/28/linux-kenel-0-11-topic-process-one-part3/" class="article-date">
  	<time datetime="2016-02-28T03:02:05.000Z" itemprop="datePublished">2016-02-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux 内核学习笔记：进程 1 的创建及执行（第 3 部分） —— 读取硬盘引导块
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内核/">内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/引导块/">引导块</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/硬盘/">硬盘</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/操作系统/">操作系统</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文接着上一博文 <a href="http://xiehongfeng100.github.io/2016/02/26/linux-kenel-0-11-topic-process-one-part2/">Linux 内核学习笔记：进程 1 创建及执行（第 2 部分）</a>最后的“调用 sys_setup”继续写下去。</p>
<h1 id="调用-sys-setup"><a href="#调用-sys-setup" class="headerlink" title="调用 sys_setup"></a><strong>调用 sys_setup</strong></h1><p>根据 sys_setup 函数，我们分成几个部分来对其进行解释。</p>
<h2 id="进程-1-设置硬盘的-hd-info"><a href="#进程-1-设置硬盘的-hd-info" class="headerlink" title="进程 1 设置硬盘的 hd_info"></a><strong>进程 1 设置硬盘的 hd_info</strong></h2><p>阅读这部分，请先参考以下两篇博文有关“硬盘”部分：<br><a href="http://xiehongfeng100.github.io/2016/01/29/linux-kenel-0-11-topic-necessary-preparation-part8/">Linux 内核学习笔记：预备知识之“硬盘基础知识”</a><br><a href="http://xiehongfeng100.github.io/2016/02/18/linux-kenel-0-11-topic-boot-part3/">Linux 内核学习笔记：内核引导程序之“setup.s”</a></p>
<p>参考以下博文有关“CMOS”部分：<br><a href="http://xiehongfeng100.github.io/2016/02/22/linux-kenel-0-11-topic-init-part2/">Linux 内核学习笔记：初始化程序（第 2 部分）</a></p>
<a id="more"></a>
<p>这部分代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kenel/blk_drv/hd.c --------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_HD		2	<span class="comment">// 最多有两块硬盘</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hd_i_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">// 磁头数、每磁道扇区数、柱面数、写前预补偿柱面号、磁头着陆（停止）柱面号、控制字节</span></span><br><span class="line">	<span class="comment">// 请参考博文：Linux 内核学习笔记：内核引导程序之“setup.s”</span></span><br><span class="line">	<span class="comment">// 链接：http://xiehongfeng100.github.io/2016/02/18/linux-kenel-0-11-topic-boot-part3/</span></span><br><span class="line">	<span class="keyword">int</span> head,sect,cyl,wpcom,lzone,ctl;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HD_TYPE	<span class="comment">// 如果已经在 include/linux/config.h 中定义了 HD_TYPE</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hd_i_struct</span> <span class="title">hd_info</span>[] = &#123;</span> HD_TYPE &#125;;	<span class="comment">// 取定义好的参数作为 hd_info[] 的数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_HD ((sizeof (hd_info))/(sizeof (struct hd_i_struct)))	<span class="comment">// 计算硬盘数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">// 否则，都设置为 0</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hd_i_struct</span> <span class="title">hd_info</span>[] = &#123;</span> &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NR_HD = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义硬盘分区结构。给出每个分区的物理起始扇区号、分区的扇区总数</span></span><br><span class="line"><span class="comment">// 其中 5 的倍数处（hd[0] 和 hd[5]）代表整个硬盘的参数</span></span><br><span class="line"><span class="comment">// Linux 0.11 最多支持两个硬盘，而每个硬盘最多可分为 4 个主分区，</span></span><br><span class="line"><span class="comment">// 再加上表示整个硬盘的 hd[0] 和 hd[5]，hd 数组大小总共为 2 + 4 * 2 = 10</span></span><br><span class="line"><span class="comment">// 请参考博文：Linux 内核学习笔记：预备知识之“硬盘基础知识”</span></span><br><span class="line"><span class="comment">// 链接：http://xiehongfeng100.github.io/2016/01/29/linux-kenel-0-11-topic-necessary-preparation-part8/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> start_sect;</span><br><span class="line">	<span class="keyword">long</span> nr_sects;</span><br><span class="line">&#125; hd[<span class="number">5</span>*MAX_HD]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This may be used only once, enforced by 'static int callable' */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_setup</span><span class="params">(<span class="keyword">void</span> * BIOS)</span>	<span class="comment">// BIOS 在这里值的是 DRIVE_INFO （0x90080）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> callable = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> i,drive;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> cmos_disks;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化时为 1，当运行该函数时设置为 0，使本函数只能运行一次</span></span><br><span class="line">	<span class="keyword">if</span> (!callable)	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	callable = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HD_TYPE	<span class="comment">// 如果没有在 include/linux/config.h 中定义 HD_TYPE，就从 DRIVE_INFO （0x90080）处读入</span></span></span><br><span class="line">	<span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;<span class="number">2</span> ; drive++) &#123;</span><br><span class="line">		hd_info[drive].cyl = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) BIOS;</span><br><span class="line">		hd_info[drive].head = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">2</span>+BIOS);</span><br><span class="line">		hd_info[drive].wpcom = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (<span class="number">5</span>+BIOS);</span><br><span class="line">		hd_info[drive].ctl = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">8</span>+BIOS);</span><br><span class="line">		hd_info[drive].lzone = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (<span class="number">12</span>+BIOS);</span><br><span class="line">		hd_info[drive].sect = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">14</span>+BIOS);</span><br><span class="line">		BIOS += <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// setup.s 程序在取 BIOS 中的硬盘信息时，如果只有 1 个硬盘，就会将对应第 2 个硬盘的 16B 清零</span></span><br><span class="line">	<span class="comment">// 因此这里只要判断第 2 个硬盘柱面数是否为 0 就可以知道有没有第 2 个硬盘了</span></span><br><span class="line">	<span class="keyword">if</span> (hd_info[<span class="number">1</span>].cyl)</span><br><span class="line">		NR_HD=<span class="number">2</span>;	<span class="comment">// 硬盘数设置为 2</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		NR_HD=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">// 设置每个硬盘的起始扇区号和扇区总数，即设置 hd[0] 和 hd[5]</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_HD ; i++) &#123;</span><br><span class="line">		hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">		hd[i*<span class="number">5</span>].nr_sects = hd_info[i].head*</span><br><span class="line">				hd_info[i].sect*hd_info[i].cyl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CMOS 在 0x12 处存放的是“硬盘驱动类型”</span></span><br><span class="line">	<span class="comment">// 下述代码判断硬盘是不是 AT 控制器兼容的</span></span><br><span class="line">	<span class="comment">// 请参考博文：Linux 内核学习笔记：初始化程序（第 2 部分）</span></span><br><span class="line">	<span class="comment">// 链接：http://xiehongfeng100.github.io/2016/02/22/linux-kenel-0-11-topic-init-part2/</span></span><br><span class="line">	<span class="keyword">if</span> ((cmos_disks = CMOS_READ(<span class="number">0x12</span>)) &amp; <span class="number">0xf0</span>)</span><br><span class="line">		<span class="keyword">if</span> (cmos_disks &amp; <span class="number">0x0f</span>)</span><br><span class="line">			NR_HD = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			NR_HD = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		NR_HD = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 若 NR_HD = 0，则两硬盘都不是 AT 兼容的，硬盘数据结构清零</span></span><br><span class="line">	<span class="keyword">for</span> (i = NR_HD ; i &lt; <span class="number">2</span> ; i++) &#123;</span><br><span class="line">		hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">		hd[i*<span class="number">5</span>].nr_sects = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init/main.c ---------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMOS_READ(addr) (&#123; \</span></span><br><span class="line">outb_p(<span class="number">0x80</span>|addr,<span class="number">0x70</span>); \</span><br><span class="line">inb_p(<span class="number">0x71</span>); \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="读取硬盘引导块到缓冲区"><a href="#读取硬盘引导块到缓冲区" class="headerlink" title="读取硬盘引导块到缓冲区"></a><strong>读取硬盘引导块到缓冲区</strong></h2><p>在 Linux 0.11 中，硬盘最基础的信息就是<code>分区表</code>，其他信息都可以从这个信息引导出来。这个信息所在的块就是<code>引导块</code>。一块硬盘只有唯一的一个引导快，即硬盘的 0 号逻辑块。<code>引导块占用两个扇区，真正有用的是第一个扇区。</code></p>
<p>一个硬盘分区的例子如下：<br><img src="/images/os/linux-kenel-0.11/process-one/part3/硬盘上分区.png" alt>图片来源：《Linux 内核完全注释》（编辑过）  </p>
<p><strong>注：</strong>为了更好理解接下来内容，可以先查看之前博文 <a href="http://xiehongfeng100.github.io/2016/02/24/linux-kenel-0-11-topic-init-part4/">Linux 内核学习笔记：初始化程序（第 4 部分）</a>“缓冲区结构初始化”部分。</p>
<h3 id="调用-bread"><a href="#调用-bread" class="headerlink" title="调用 bread"></a><strong>调用 bread</strong></h3><p>下面程序把引导块读入缓冲区，以便后续程序解读引导块中的信息。这个工作是通过 bread 函数（bread 可理解为 block read）实现的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kenel/blk_drv/hd.c --------------------------</span></span><br><span class="line"><span class="comment">/* This may be used only once, enforced by 'static int callable' */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_setup</span><span class="params">(<span class="keyword">void</span> * BIOS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,drive;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一个硬盘的设备号是 0x300，第 2 个是 0x305</span></span><br><span class="line">	<span class="comment">// 读每个硬盘的 0 号块，即引导块</span></span><br><span class="line">	<span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;</span><br><span class="line">			printk(<span class="string">"Unable to read partition table of drive %d\n\r"</span>,</span><br><span class="line">				drive);</span><br><span class="line">			panic(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fs/buffer.c ---------------------------------</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bread() reads a specified block and returns the buffer that contains</span></span><br><span class="line"><span class="comment"> * it. It returns NULL if the block was unreadable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">bread</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在缓冲区申请一块缓冲块。如果返回 NULL，表示内核出错，死机</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh=getblk(dev,block)))	<span class="comment">// getblk -&gt; get block</span></span><br><span class="line">		panic(<span class="string">"bread: getblk returned NULL\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若该缓冲块中数据是有效的（已更新），则可以直接使用，返回</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate)</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则调用 ll_rw_block，产生读设备请求，并等待该缓冲块解锁</span></span><br><span class="line">	ll_rw_block(READ,bh);</span><br><span class="line">	wait_on_buffer(bh);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若该缓冲块中数据是有效的（已更新），则可以直接使用，返回</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate)</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则表明读设备操作失败，释放该缓冲块，返回 NULL 指针</span></span><br><span class="line">	brelse(bh);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bread 函数的执行流程框图如下所示：<br><img src="/images/os/linux-kenel-0.11/process-one/part3/bread函数执行流程框图.png" alt>图片来源：《Linux 内核完全注释》  </p>
<h3 id="调用-getblk"><a href="#调用-getblk" class="headerlink" title="调用 getblk"></a><strong>调用 getblk</strong></h3><p>getblk 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/buffer.c ---------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BADNESS(bh) (((bh)-&gt;b_dirt<span class="meta-string">&lt;&lt;1)+(bh)-&gt;b_lock)	// 该宏定义用于同时判断缓冲块的修改标志和锁定标志</span></span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">getblk</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">tmp</span>, * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">	<span class="comment">// 搜索 Hash 表，如果指定缓冲块已经在缓存区中，则返回对应缓冲块头指针</span></span><br><span class="line">	<span class="keyword">if</span> (bh = get_hash_table(dev,block))</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描空闲缓冲块链表，寻找空闲缓冲块</span></span><br><span class="line">	tmp = free_list;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// 如果该缓冲块正被使用（引用计数不为 0），则继续扫描下一项</span></span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;b_count)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 如果缓冲块头指针 bh 为空，或者 tmp 所指向的缓冲块标志（b_dir、b_lock）权重小于 bh 的对应权重，</span></span><br><span class="line">		<span class="comment">// 则让 bh 指向该 tmp 所指向的缓冲块。如果 tmp 所指向的缓冲块的修改和锁定标志位为 0，则说明已为指</span></span><br><span class="line">		<span class="comment">// 定设备上的块取得对应的缓冲块，退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (!bh || BADNESS(tmp)&lt;BADNESS(bh)) &#123;</span><br><span class="line">			bh = tmp;</span><br><span class="line">			<span class="keyword">if</span> (!BADNESS(tmp))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">/* and repeat until we find something good */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> ((tmp = tmp-&gt;b_next_free) != free_list);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果所有缓冲块正被使用，则睡眠 ，等待有空闲的缓冲区可用</span></span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		sleep_on(&amp;buffer_wait);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待该缓冲块解锁（如果被加锁的话）</span></span><br><span class="line">	wait_on_buffer(bh);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这寻找可用缓冲块期间，有可能其他任务使用了该缓冲块（因为存在任务切换）</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_count)</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果缓冲块已被修改，则将数据写盘，并再次等待缓冲块解锁。如果缓冲块又被其他任务使用，只好重复以上过程</span></span><br><span class="line">	<span class="keyword">while</span> (bh-&gt;b_dirt) &#123;</span><br><span class="line">		sync_dev(bh-&gt;b_dev);</span><br><span class="line">		wait_on_buffer(bh);</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_count)</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NOTE!! While we slept waiting for this block, somebody else might */</span></span><br><span class="line"><span class="comment">/* already have added "this" block to the cache. check it */</span></span><br><span class="line"><span class="comment">// 注意！！当进程为了等待该缓冲块而睡眠时，其他进程可能已经将该缓冲块加入到 Hash 表</span></span><br><span class="line"><span class="comment">// 检查指定缓冲块是否已经被加入 Hash 表。如果是的话，就重复以上过程</span></span><br><span class="line">	<span class="keyword">if</span> (find_buffer(dev,block))</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK, FINALLY we know that this buffer is the only one of it's kind, */</span></span><br><span class="line"><span class="comment">/* and that it's unused (b_count=0), unlocked (b_lock=0), and clean */</span></span><br><span class="line"><span class="comment">// 最终我们知道该缓冲块是指定参数唯一的一块，而且还没有被使用（b_count=0），未被上锁（b_lock=0）</span></span><br><span class="line"><span class="comment">// 并且是干净的（未被修改的）。于是我们占用此缓冲块。</span></span><br><span class="line">	bh-&gt;b_count=<span class="number">1</span>;</span><br><span class="line">	bh-&gt;b_dirt=<span class="number">0</span>;</span><br><span class="line">	bh-&gt;b_uptodate=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 从 Hash 表和空闲缓冲块链表中移出该缓冲块，让该缓冲块用于指定设备和该设备上的指定块</span></span><br><span class="line">	remove_from_queues(bh);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 然后根据新的设备号和块号，将该缓冲块重新加入到 Hash 表和空闲缓冲块链表中</span></span><br><span class="line">	<span class="comment">// 注意，块号 b_blocknr 指的是设备上的块号，并不是缓冲块的（缓冲块已经有 b_data 指向，不必编号）</span></span><br><span class="line">	<span class="comment">// 之所以要由“先移除在添加”这个过程，可能是为了调整空闲缓冲块链表，将刚被使用的缓冲块放到最后</span></span><br><span class="line">	bh-&gt;b_dev=dev;</span><br><span class="line">	bh-&gt;b_blocknr=block;</span><br><span class="line">	insert_into_queues(bh);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getblk 函数执行流程图如下所示：<br><img src="/images/os/linux-kenel-0.11/process-one/part3/getblk函数执行流程图.png" alt>图片来源：《Linux 内核完全注释》  </p>
<p>为了完整，特地将 getblk 函数调用的函数摘录：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请参考之前博文： Linux 内核学习笔记：初始化程序（第 4 部分）“缓冲区结构初始化”部分以了解 Hash 表</span></span><br><span class="line"><span class="comment">// 链接：http://xiehongfeng100.github.io/2016/02/24/linux-kenel-0-11-topic-init-part4/)</span></span><br><span class="line"><span class="comment">// fs/buffer.c ---------------------------------</span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">get_hash_table</span><span class="params">(<span class="keyword">int</span> dev, <span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(bh=find_buffer(dev,block)))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		bh-&gt;b_count++;</span><br><span class="line">		wait_on_buffer(bh);</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_dev == dev &amp;&amp; bh-&gt;b_blocknr == block)</span><br><span class="line">			<span class="keyword">return</span> bh;</span><br><span class="line">		bh-&gt;b_count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找缓冲区中是否已经有指定设备号、块号的缓冲块</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct buffer_head * <span class="title">find_buffer</span><span class="params">(<span class="keyword">int</span> dev, <span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;		</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (tmp = hash(dev,block) ; tmp != <span class="literal">NULL</span> ; tmp = tmp-&gt;b_next)</span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;b_dev==dev &amp;&amp; tmp-&gt;b_blocknr==block)</span><br><span class="line">			<span class="keyword">return</span> tmp;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NR_HASH = 307。对于 dev = 0x300、block = 0 而言，_hashfn(dev,block) 的值是 154</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">hash_table</span>[<span class="title">NR_HASH</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _hashfn(dev,block) (((unsigned)(dev^block))%NR_HASH)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hash(dev,block) hash_table[_hashfn(dev,block)]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">remove_from_queues</span><span class="params">(struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* remove from hash-queue */</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_next)</span><br><span class="line">		bh-&gt;b_next-&gt;b_prev = bh-&gt;b_prev;</span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_prev)</span><br><span class="line">		bh-&gt;b_prev-&gt;b_next = bh-&gt;b_next;</span><br><span class="line">	<span class="keyword">if</span> (hash(bh-&gt;b_dev,bh-&gt;b_blocknr) == bh)</span><br><span class="line">		hash(bh-&gt;b_dev,bh-&gt;b_blocknr) = bh-&gt;b_next;</span><br><span class="line"><span class="comment">/* remove from free list */</span></span><br><span class="line">	<span class="keyword">if</span> (!(bh-&gt;b_prev_free) || !(bh-&gt;b_next_free))</span><br><span class="line">		panic(<span class="string">"Free block list corrupted"</span>);</span><br><span class="line">	bh-&gt;b_prev_free-&gt;b_next_free = bh-&gt;b_next_free;</span><br><span class="line">	bh-&gt;b_next_free-&gt;b_prev_free = bh-&gt;b_prev_free;</span><br><span class="line">	<span class="keyword">if</span> (free_list == bh)</span><br><span class="line">		free_list = bh-&gt;b_next_free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert_into_queues</span><span class="params">(struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* put at end of free list */</span></span><br><span class="line">	bh-&gt;b_next_free = free_list;</span><br><span class="line">	bh-&gt;b_prev_free = free_list-&gt;b_prev_free;</span><br><span class="line">	free_list-&gt;b_prev_free-&gt;b_next_free = bh;</span><br><span class="line">	free_list-&gt;b_prev_free = bh;</span><br><span class="line"><span class="comment">/* put the buffer in new hash-queue if it has a device */</span></span><br><span class="line">	bh-&gt;b_prev = <span class="literal">NULL</span>;</span><br><span class="line">	bh-&gt;b_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!bh-&gt;b_dev)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	bh-&gt;b_next = hash(bh-&gt;b_dev,bh-&gt;b_blocknr);</span><br><span class="line">	hash(bh-&gt;b_dev,bh-&gt;b_blocknr) = bh;</span><br><span class="line">	bh-&gt;b_next-&gt;b_prev = bh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="调用-ll-rw-block"><a href="#调用-ll-rw-block" class="headerlink" title="调用 ll_rw_block"></a><strong>调用 ll_rw_block</strong></h3><p>getblk 函数返回后，已经为“指定设备号（dev）、块号（block）”申请到一个缓冲块，但该缓冲块的数据还没更新。接下来开始执行下边代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/buffer.c ---------------------------------</span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">bread</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	......	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则调用 ll_rw_block，产生读设备请求，并等待该缓冲块解锁</span></span><br><span class="line">	ll_rw_block(READ,bh);</span><br><span class="line">	wait_on_buffer(bh);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若该缓冲块中数据是有效的（已更新），则可以直接使用，返回</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate)</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">	<span class="comment">// 否则表明读设备操作失败，释放该缓冲块，返回 NULL 指针</span></span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/blk_drv/ll_rw_block.c ----------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ll_rw_block</span><span class="params">(<span class="keyword">int</span> rw, struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> major;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果设备的主设备号不存在或者该设备的读写操作函数不存在，则显示出错信息，返回</span></span><br><span class="line">	<span class="keyword">if</span> ((major=MAJOR(bh-&gt;b_dev)) &gt;= NR_BLK_DEV ||</span><br><span class="line">	!(blk_dev[major].request_fn)) &#123;		<span class="comment">// 注意：这里并不是调用 request_fn() 函数。request_fn 和 request_fn() 是不一样的</span></span><br><span class="line">		printk(<span class="string">"Trying to read nonexistent block-device\n\r"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	make_request(major,rw,bh);	<span class="comment">// 创建一个请求结构项，并将该请求结构项插入到该设备的请求队列中，最后执行块设备的请求函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="调用-make-request"><a href="#调用-make-request" class="headerlink" title="调用 make_request"></a><strong>调用 make_request</strong></h3><p>make_request 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/blk_drv/ll_rw_block.c ----------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_request</span><span class="params">(<span class="keyword">int</span> major,<span class="keyword">int</span> rw, struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">req</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rw_ahead;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* WRITEA/READA is special case - it is not really needed, so if the */</span></span><br><span class="line"><span class="comment">/* buffer is locked, we just forget about it, else it's a normal read */</span></span><br><span class="line">	<span class="keyword">if</span> (rw_ahead = (rw == READA || rw == WRITEA)) &#123;	<span class="comment">// A -&gt; Ahead，表示预读</span></span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_lock)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (rw == READA)</span><br><span class="line">			rw = READ;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rw = WRITE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rw!=READ &amp;&amp; rw!=WRITE)</span><br><span class="line">		panic(<span class="string">"Bad block dev command, must be R/W/RA/WA"</span>);</span><br><span class="line">	lock_buffer(bh);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果命令是写并且缓冲区数据不脏，或者命令是读并且数据是更新过的，则不用添加这个请求，将缓冲块解锁并退出。</span></span><br><span class="line">	<span class="comment">// 第 1 个条件：向设备的写一般是批量的写，也就是等缓冲区有足够的数据才开始向设备写。所以，如果是写命令的话，可以先</span></span><br><span class="line">	<span class="comment">// 向缓冲区写，等条件满足了再向设备写，而向设备写由请求项函数来处理就行了</span></span><br><span class="line">	<span class="comment">// 第 2 个条件：如果数据已经更新了，说明设备上的数据已经被（其他进程）读进缓冲块，就没必要再读一次了</span></span><br><span class="line">	<span class="keyword">if</span> ((rw == WRITE &amp;&amp; !bh-&gt;b_dirt) || (rw == READ &amp;&amp; bh-&gt;b_uptodate)) &#123;</span><br><span class="line">		unlock_buffer(bh);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">repeat:</span><br><span class="line"><span class="comment">/* we don't allow the write-requests to fill up the queue completely:</span></span><br><span class="line"><span class="comment"> * we want some room for reads: they take precedence. The last third</span></span><br><span class="line"><span class="comment"> * of the requests are only for reads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="comment">// 读从尾端开始，写从 2/3 处开始</span></span><br><span class="line">	<span class="keyword">if</span> (rw == READ)</span><br><span class="line">		req = request+NR_REQUEST;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		req = request+((NR_REQUEST*<span class="number">2</span>)/<span class="number">3</span>);</span><br><span class="line"><span class="comment">/* find an empty request */</span></span><br><span class="line">	<span class="keyword">while</span> (--req &gt;= request)	<span class="comment">// 从后往前搜索空闲块设备请求项，在 blk_dev_init 中，dev 初始化为 -1</span></span><br><span class="line">		<span class="keyword">if</span> (req-&gt;dev&lt;<span class="number">0</span>)		<span class="comment">// 找到空闲请求项</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* if none found, sleep on new requests: check for rw_ahead */</span></span><br><span class="line">	<span class="keyword">if</span> (req &lt; request) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rw_ahead) &#123;</span><br><span class="line">			unlock_buffer(bh);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sleep_on(&amp;wait_for_request);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* fill up the request-info, and add it to the queue */</span></span><br><span class="line">	req-&gt;dev = bh-&gt;b_dev;	<span class="comment">// 设置块设备请求项</span></span><br><span class="line">	req-&gt;cmd = rw;</span><br><span class="line">	req-&gt;errors=<span class="number">0</span>;</span><br><span class="line">	req-&gt;sector = bh-&gt;b_blocknr&lt;&lt;<span class="number">1</span>;	<span class="comment">// 起始扇区，1 块 = 2 个扇区</span></span><br><span class="line">	req-&gt;nr_sectors = <span class="number">2</span>;</span><br><span class="line">	req-&gt;buffer = bh-&gt;b_data;</span><br><span class="line">	req-&gt;waiting = <span class="literal">NULL</span>;</span><br><span class="line">	req-&gt;bh = bh;</span><br><span class="line">	req-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	add_request(major+blk_dev,req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lock_buffer</span><span class="params">(struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cli();</span><br><span class="line">	<span class="keyword">while</span> (bh-&gt;b_lock)</span><br><span class="line">		sleep_on(&amp;bh-&gt;b_wait);</span><br><span class="line">	bh-&gt;b_lock=<span class="number">1</span>;</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unlock_buffer</span><span class="params">(struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!bh-&gt;b_lock)</span><br><span class="line">		printk(<span class="string">"ll_rw_block.c: buffer not locked\n\r"</span>);</span><br><span class="line">	bh-&gt;b_lock = <span class="number">0</span>;</span><br><span class="line">	wake_up(&amp;bh-&gt;b_wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="调用-add-request"><a href="#调用-add-request" class="headerlink" title="调用 add_request"></a><strong>调用 add_request</strong></h3><p>add_request 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/blk_drv/ll_rw_block.c ----------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_request</span><span class="params">(struct blk_dev_struct * dev, struct request * req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	req-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	cli();</span><br><span class="line">	<span class="keyword">if</span> (req-&gt;bh)</span><br><span class="line">		req-&gt;bh-&gt;b_dirt = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果 dev 的当前请求（current_request）字段为空，则表示目前“该设备”（注意！！！不同设备会有不同请求链表）</span></span><br><span class="line">	<span class="comment">// 没有请求项，本次是“该设备”的第 1 个请求项，因此可将“该设备”当前请求指针直接指向该请求项</span></span><br><span class="line">	<span class="keyword">if</span> (!(tmp = dev-&gt;current_request)) &#123;</span><br><span class="line">		dev-&gt;current_request = req;</span><br><span class="line">		sti();</span><br><span class="line">		(dev-&gt;request_fn)();	<span class="comment">// 执行块设备请求函数，对于硬盘是 do_hd_request()</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若“该设备”已经有请求项在等待，则首先利用电梯算法搜索最佳位置，然后将该请求项插入“该设备”请求链表中</span></span><br><span class="line">	<span class="keyword">for</span> ( ; tmp-&gt;next ; tmp=tmp-&gt;next)</span><br><span class="line">		<span class="keyword">if</span> ((IN_ORDER(tmp,req) ||</span><br><span class="line">		    !IN_ORDER(tmp,tmp-&gt;next)) &amp;&amp;</span><br><span class="line">		    IN_ORDER(req,tmp-&gt;next))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	req-&gt;next=tmp-&gt;next;</span><br><span class="line">	tmp-&gt;next=req;</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="调用-do-hd-request"><a href="#调用-do-hd-request" class="headerlink" title="调用 do_hd_request"></a><strong>调用 do_hd_request</strong></h3><p>do_hd_request 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/blk_drv/hd.c -------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_hd_request</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,r;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> block,dev;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sec,head,cyl;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nsect;</span><br><span class="line"></span><br><span class="line">	INIT_REQUEST;</span><br><span class="line">	dev = MINOR(CURRENT-&gt;dev);	<span class="comment">// 子设备号，对硬盘来说就是分区</span></span><br><span class="line">	block = CURRENT-&gt;sector;</span><br><span class="line">	<span class="keyword">if</span> (dev &gt;= <span class="number">5</span>*NR_HD || block+<span class="number">2</span> &gt; hd[dev].nr_sects) &#123;</span><br><span class="line">		end_request(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">	block += hd[dev].start_sect;</span><br><span class="line">	dev /= <span class="number">5</span>;</span><br><span class="line">	__asm__(<span class="string">"divl %4"</span>:<span class="string">"=a"</span> (block),<span class="string">"=d"</span> (sec):<span class="string">"0"</span> (block),<span class="string">"1"</span> (<span class="number">0</span>),</span><br><span class="line">		<span class="string">"r"</span> (hd_info[dev].sect));</span><br><span class="line">	__asm__(<span class="string">"divl %4"</span>:<span class="string">"=a"</span> (cyl),<span class="string">"=d"</span> (head):<span class="string">"0"</span> (block),<span class="string">"1"</span> (<span class="number">0</span>),</span><br><span class="line">		<span class="string">"r"</span> (hd_info[dev].head));</span><br><span class="line">	sec++;</span><br><span class="line">	nsect = CURRENT-&gt;nr_sectors;</span><br><span class="line">	<span class="keyword">if</span> (reset) &#123;</span><br><span class="line">		reset = <span class="number">0</span>;</span><br><span class="line">		recalibrate = <span class="number">1</span>;</span><br><span class="line">		reset_hd(CURRENT_DEV);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (recalibrate) &#123;</span><br><span class="line">		recalibrate = <span class="number">0</span>;</span><br><span class="line">		hd_out(dev,hd_info[CURRENT_DEV].sect,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">			WIN_RESTORE,&amp;recal_intr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写操作</span></span><br><span class="line">	<span class="keyword">if</span> (CURRENT-&gt;cmd == WRITE) &#123;</span><br><span class="line">		hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&amp;write_intr);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;<span class="number">3000</span> &amp;&amp; !(r=inb_p(HD_STATUS)&amp;DRQ_STAT) ; i++)</span><br><span class="line">			<span class="comment">/* nothing */</span> ;</span><br><span class="line">		<span class="keyword">if</span> (!r) &#123;</span><br><span class="line">			bad_rw_intr();</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">		&#125;</span><br><span class="line">		port_write(HD_DATA,CURRENT-&gt;buffer,<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读操作</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CURRENT-&gt;cmd == READ) &#123;</span><br><span class="line">		hd_out(dev,nsect,sec,head,cyl,WIN_READ,&amp;read_intr);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		panic(<span class="string">"unknown hd-command"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/blk_drv/blk.h ------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURRENT (blk_dev[MAJOR_NR].current_request)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURRENT_DEV DEVICE_NR(CURRENT-&gt;dev)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_REQUEST \</span></span><br><span class="line">repeat: \</span><br><span class="line">	<span class="keyword">if</span> (!CURRENT) \</span><br><span class="line">		<span class="keyword">return</span>; \</span><br><span class="line">	<span class="keyword">if</span> (MAJOR(CURRENT-&gt;dev) != MAJOR_NR) \</span><br><span class="line">		panic(DEVICE_NAME <span class="string">": request list destroyed"</span>); \</span><br><span class="line">	<span class="keyword">if</span> (CURRENT-&gt;bh) &#123; \</span><br><span class="line">		<span class="keyword">if</span> (!CURRENT-&gt;bh-&gt;b_lock) \</span><br><span class="line">			panic(DEVICE_NAME <span class="string">": block not locked"</span>); \</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/fs.h --------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR(a) ((a)&amp;0xff)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="调用-hd-out"><a href="#调用-hd-out" class="headerlink" title="调用 hd_out"></a><strong>调用 hd_out</strong></h3><p>hd_out 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/blk_drv/hd.c -------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hd_out</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> drive,<span class="keyword">unsigned</span> <span class="keyword">int</span> nsect,<span class="keyword">unsigned</span> <span class="keyword">int</span> sect,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">int</span> head,<span class="keyword">unsigned</span> <span class="keyword">int</span> cyl,<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">void</span> (*intr_addr)(<span class="keyword">void</span>))</span>	<span class="comment">// 注意该函数最后一个参数是函数指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">register</span> <span class="keyword">int</span> port <span class="title">asm</span><span class="params">(<span class="string">"dx"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (drive&gt;<span class="number">1</span> || head&gt;<span class="number">15</span>)</span><br><span class="line">		panic(<span class="string">"Trying to write bad sector"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!controller_ready())</span><br><span class="line">		panic(<span class="string">"HD controller not ready"</span>);</span><br><span class="line">	do_hd = intr_addr;	<span class="comment">// 将读/写盘服务程序与硬盘中断操作程序相挂接。在这里，do_hd = read_intr</span></span><br><span class="line">	outb_p(hd_info[drive].ctl,HD_CMD);</span><br><span class="line">	port=HD_DATA;</span><br><span class="line">	outb_p(hd_info[drive].wpcom&gt;&gt;<span class="number">2</span>,++port);</span><br><span class="line">	outb_p(nsect,++port);</span><br><span class="line">	outb_p(sect,++port);</span><br><span class="line">	outb_p(cyl,++port);</span><br><span class="line">	outb_p(cyl&gt;&gt;<span class="number">8</span>,++port);</span><br><span class="line">	outb_p(<span class="number">0xA0</span>|(drive&lt;&lt;<span class="number">4</span>)|head,++port);</span><br><span class="line">	outb(cmd,++port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>do_hd 定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/system_call.s ------------------------</span></span><br><span class="line">_hd_interrupt:</span><br><span class="line">	......</span><br><span class="line">	jmp <span class="number">1f</span>			<span class="meta"># give port chance to breathe</span></span><br><span class="line"><span class="number">1</span>:	jmp <span class="number">1f</span></span><br><span class="line"><span class="number">1</span>:	xorl %edx,%edx</span><br><span class="line">	xchgl _do_hd,%edx	# do_hd 是函数指针，将被赋值 read_intr 或 write_intr 函数地址</span><br><span class="line">				# 交换后，do_hd 被置为 <span class="literal">NULL</span></span><br><span class="line">	......</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，<strong><code>现在只是将硬盘中断服务程序挂接到 read_intr，同时给硬盘发命令，指明要读取的数据。接下来，硬盘将指定的数据读取到硬盘缓冲区。这个过程很耗时，而且不用 CPU 干预，所以 CPU 可以去做其他事情。</code></strong></p>
<p>接下来，CPU 利用硬盘读取数据的空档，去做点其他事情。</p>
<h3 id="题外：硬盘"><a href="#题外：硬盘" class="headerlink" title="题外：硬盘"></a><strong>题外：硬盘</strong></h3><p>一直以来对（单） CPU 能够在读取硬盘同时还能够去做其他事情感到很奇怪，但通过搜索提示，突然想通了：  </p>
<ol>
<li>CPU 通过“硬盘驱动程序”给硬盘下达读数据的指令</li>
<li>硬盘开始寻找要读取的扇区并读取数据，且把这些数据存放在<code>硬盘缓冲区</code></li>
<li>第 2 步是一个很耗时而且<code>不用 CPU 干预</code>的过程，所以 CPU 在这段时间可以去做其他事情</li>
<li>硬盘把数据读取到<code>硬盘缓冲区</code>完毕后，给 CPU 发中断</li>
<li>CPU 中断正在做的其他事，去把<code>硬盘缓冲区</code>的数据读取到”内存缓冲区”（如用 rep insw 指令），整个数据读取过程结束。</li>
</ol>
<p>硬盘每次只读取一个扇区（512B），但这过程包括了硬盘的<a href="http://blog.chinaunix.net/uid-23069658-id-3413957.html" target="_blank" rel="noopener">寻道（Seek time）、旋转延迟（Rotational latency time）</a>的过程，对时间消耗远大于 CPU 执行执行的速度。</p>
<p>为了看看有没有更好的解释，还特地在 Quora 上提了一个问题：<a href="https://www.quora.com/How-can-a-CPU-do-other-things-while-reading-hard-disk" target="_blank" rel="noopener">How can a CPU do other things while reading hard disk?</a>。好快就有一个叫 <a href="https://www.quora.com/profile/Andrew-Daviel" target="_blank" rel="noopener">Andrew-Daviel</a> 解答了（太 Nice）：  </p>
<blockquote>
<ul>
<li>A couple of ways. Modern operating systems are multitasking. They also have multiple cores (multiple CPUs), so not only can they appear to do two things at once by splitting time between two tasks (do a bit of one task, get a clock interrupt, switch to another task for a bit, get another interrupt, swap back etc.), they can do two things at once for real because one task can run on one CPU and another task on another.</li>
<li>Also, disks use DMA (direct memory access). The disk controller is able to transfer data directly from the disk to the computer RAM and interrupt the CPU when it is finished. Computer buses are able to apparently do two things at ones since the different bus masters (CPU, disk controller, video controller, network interface etc.) negotiate for access to the bus and send data words or data bursts interleaved with other devices. Much the same as traffic-controlled lights in a city allow cars to cross an intersection. When you run a computer program, you are like the passenger on a bus - driving the bus and knowing when to stop for red lights is the driver’s problem, not yours.</li>
</ul>
</blockquote>
<h3 id="切换到进程-0"><a href="#切换到进程-0" class="headerlink" title="切换到进程 0"></a><strong>切换到进程 0</strong></h3><p>如果程序继续执行，则需要对引导块中的数据进行操作。但因为硬盘的读写速度远低于 CPU 执行指令的速度（低 2~3 个数量级），所以在从硬盘读取数据过程中，会调用 wait_on_buffer 函数，挂起等待；然后 CPU 切换到其他进程执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/buffer.c ---------------------------------</span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">bread</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	ll_rw_block(READ,bh);</span><br><span class="line">	wait_on_buffer(bh);</span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate)</span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wait_on_buffer</span><span class="params">(struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cli();</span><br><span class="line">	<span class="keyword">while</span> (bh-&gt;b_lock)</span><br><span class="line">		sleep_on(&amp;bh-&gt;b_wait);</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sched.c ------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_on</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">		panic(<span class="string">"task[0] trying to sleep"</span>);</span><br><span class="line">	tmp = *p;</span><br><span class="line">	*p = current;</span><br><span class="line">	current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">if</span> (tmp)</span><br><span class="line">		tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当执行到 sleep_on 函数时，将当前任务（进程 1）的状态设置为不可中断的等待状态，并调用 schedule 函数进行任务调度。但这里有个问题，就是系统目前只有进程 0 和进程 1，进程 1 已经被挂起，进程 0 处于 TASK_INTERRUPTIBLE 状态（见 <a href="http://xiehongfeng100.github.io/2016/02/26/linux-kenel-0-11-topic-process-one-part2/">sys_pause</a> 函数），都不具备 schedule 函数中的条件 <code>(*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c</code>，所以理论上无法从进程 1 切换到进程 0，也没有进程可以运行。</p>
<p>不过按照《Linux 内核设计的艺术》的说法，<code>操作系统会强行切换到进程 0</code>。具体原因个人也不清楚。Linus 在 init/main.c 函数为 <code>for(;;) pause();</code> 所写的注释倒可以作为解释：  </p>
<blockquote>
<p>For any other task ‘pause()’ would mean we have to get a signal to awaken, but task0 is the sole exception (see ‘schedule()’) as task 0 gets activated at every idle moment (when no other tasks can run). For task0 ‘pause()’ just means we go check if some other task can run, and if not we return here.</p>
</blockquote>
<p>在之前<a href="http://xiehongfeng100.github.io/2016/02/26/linux-kenel-0-11-topic-process-one-part2/">从进程 0 切换到进程 1 </a>的时候，进程 0 的 TSS 会保存当时进程 0 运行时的寄存器的值，所以切换回进程 0 的时候便可以根据 TSS 来恢复当时进程 0 运行时的场景，即从 <code>&quot;cmpl %%ecx,_last_task_used_math\n\t&quot;</code> 这一句开始执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched.h -----------------------</span></span><br><span class="line"><span class="comment">// 输入：%0 - 存放新 TSS 的偏移地址（*&amp;__tmp.a），%1 - 存放新 TSS 的段选择符（子）（*&amp;__tmp.b）</span></span><br><span class="line"><span class="comment">//	dx - 新任务 n 的段选择符（子），ecx - 新任务指针 task[n]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(n) &#123;\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">long</span> a,b;&#125; __tmp; \		<span class="comment">// 为 ljmp 的 cs、eip 准备的数据结构</span></span><br><span class="line">__asm__(<span class="string">"cmpl %%ecx,_current\n\t"</span> \	<span class="comment">// 任务 n 是当前任务吗？（current = task[n]?）</span></span><br><span class="line">	<span class="string">"je 1f\n\t"</span> \			<span class="comment">// 如果是就不用切换任务了</span></span><br><span class="line">	<span class="string">"movw %%dx,%1\n\t"</span> \		<span class="comment">// 将新任务的选择子 =&gt; *&amp;__tmp.b</span></span><br><span class="line">	<span class="string">"xchgl %%ecx,_current\n\t"</span> \	<span class="comment">// current = task[n]；ecx = 被切换的任务</span></span><br><span class="line">	<span class="string">"ljmp %0\n\t"</span> \			<span class="comment">// 执行长跳至 *&amp;__tmp，造成任务切换</span></span><br><span class="line">					<span class="comment">// 执行任务切换回来后才会继续执行下面的语句</span></span><br><span class="line">	<span class="string">"cmpl %%ecx,_last_task_used_math\n\t"</span> \	<span class="comment">// 新任务上次使用过协处理器吗？</span></span><br><span class="line">	<span class="string">"jne 1f\n\t"</span> \			<span class="comment">// 没有则跳转，退出</span></span><br><span class="line">	<span class="string">"clts\n"</span> \			<span class="comment">// 新任务上次使用过协处理器，清 CR0 的 TS 标志</span></span><br><span class="line">	<span class="string">"1:"</span> \</span><br><span class="line">	::<span class="string">"m"</span> (*&amp;__tmp.a),<span class="string">"m"</span> (*&amp;__tmp.b), \</span><br><span class="line">	<span class="string">"d"</span> (_TSS(n)),<span class="string">"c"</span> ((<span class="keyword">long</span>) task[n])); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在之前<a href="http://xiehongfeng100.github.io/2016/02/26/linux-kenel-0-11-topic-process-one-part2/">从进程 0 切换到进程 1 </a>，函数调用顺序是 pause -&gt; sys_pause -&gt; schedule -&gt; switch_to(1)。现在已经执行完 switch_to(1) 后半部分，就应该返回到 sys_pause、for(;;) pause() 中执行了。</p>
<p>pause 这个函数在 for(;;) 这个循环中被反复调用，所以，会继续调用 schedule 函数进行进程切换。但系统现在仅有的两个进程 0 和 1 都不是处于就绪态，不过操作系统这时会强行切换至进程 0。需要注意的是在这循环的过程中，switch_to 也被反复调用，不过因为现在是进程 0 在运行，而且要“切换”到的也是进程 0，所以 switch_to 每次基本算是被跳过：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched.h -----------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(n) &#123;\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">long</span> a,b;&#125; __tmp; \</span><br><span class="line">__asm__(<span class="string">"cmpl %%ecx,_current\n\t"</span> \</span><br><span class="line">	<span class="string">"je 1f\n\t"</span> \</span><br><span class="line">	......	<span class="comment">// 被跳过</span></span><br><span class="line">	<span class="string">"1:"</span> \</span><br><span class="line">	::<span class="string">"m"</span> (*&amp;__tmp.a),<span class="string">"m"</span> (*&amp;__tmp.b), \</span><br><span class="line">	<span class="string">"d"</span> (_TSS(n)),<span class="string">"c"</span> ((<span class="keyword">long</span>) task[n])); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="硬盘中断"><a href="#硬盘中断" class="headerlink" title="硬盘中断"></a><strong>硬盘中断</strong></h3><p>在循环 for(;;) 执行了一段时间后，硬盘在某一个时刻把一个扇区的数据读取到<code>硬盘缓冲区</code>，产生硬盘中断。CPU 接到中断指令后，终止正在执行的程序。终止的位置肯定在 pause、sys_pause、schedule、switch_to(0) 某处。不过，中断会自动压栈（ss esp eflags cs eip），中断处理完之后就能够返回到原来程序中继续执行。</p>
<p>接着，开始处理中断，执行 do_hd 绑定的中断服务程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/system_call.s ------------------------</span></span><br><span class="line">_hd_interrupt:</span><br><span class="line">	......</span><br><span class="line">	jmp <span class="number">1f</span>			<span class="meta"># give port chance to breathe</span></span><br><span class="line"><span class="number">1</span>:	jmp <span class="number">1f</span></span><br><span class="line"><span class="number">1</span>:	xorl %edx,%edx</span><br><span class="line">	xchgl _do_hd,%edx	# do_hd 是函数指针，将被赋值 read_intr 或 write_intr 函数地址</span><br><span class="line">				# 交换后，do_hd 被置为 <span class="literal">NULL</span></span><br><span class="line">	testl %edx,%edx</span><br><span class="line">	jne <span class="number">1f</span></span><br><span class="line">	movl $_unexpected_hd_interrupt,%edx</span><br><span class="line"><span class="number">1</span>:	outb %al,$<span class="number">0x20</span></span><br><span class="line">	call *%edx		# <span class="string">"interesting"</span> way of handling intr.</span><br><span class="line">				# 调用 do_hd 指向的函数</span><br><span class="line">	......</span><br></pre></td></tr></table></figure></p>
<h3 id="调用-read-intr"><a href="#调用-read-intr" class="headerlink" title="调用 read_intr"></a><strong>调用 read_intr</strong></h3><p>read_intr 函数通过硬盘驱动程序，从<code>硬盘缓冲区</code>将数据读取到内存缓冲区中。read_intr 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/blk_drv/hd.c -------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_intr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (win_result()) &#123;</span><br><span class="line">		bad_rw_intr();</span><br><span class="line">		do_hd_request();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将数据从数据寄存器端口（HD_DATA）读取到请求项缓冲（实际是直接读取到缓冲区中的缓冲块）</span></span><br><span class="line">	port_read(HD_DATA,CURRENT-&gt;buffer,<span class="number">256</span>);</span><br><span class="line">	CURRENT-&gt;errors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 make_request 函数最后将请求项的缓冲区指针指向（内存缓冲区中的）缓冲块：req-&gt;buffer = bh-&gt;b_data;</span></span><br><span class="line">	<span class="comment">// 而每一个（内存缓冲区中的）缓冲块在 buffer_init 函数中已经初始化为由一个 buffer_head 结构体来管理</span></span><br><span class="line">	<span class="comment">// 所以 port_read 函数实际是将设备上（已读取到设备缓冲区）的数据读取到（内存缓冲区中的）缓冲块</span></span><br><span class="line">	<span class="comment">// 虽然请求项的 buffer 指针一直在累加（CURRENT-&gt;buffer += 512），但 bh-&gt;b_data 并没有累加，</span></span><br><span class="line">	<span class="comment">// 这保证了缓冲块首地址是一直知道的，以便访问该（内存缓冲区中的）缓冲块，如在 sys_setup 函数调用 bread 返回后，</span></span><br><span class="line">	<span class="comment">// 能够这样访问（内存缓冲区中的）缓冲块：bh-&gt;b_data[510] != 0x55</span></span><br><span class="line">	CURRENT-&gt;buffer += <span class="number">512</span>;		<span class="comment">// 调整请求缓冲区指针，指向新的空区</span></span><br><span class="line">	CURRENT-&gt;sector++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果再次读出的扇区数量还没有读完，则再次置硬盘调用 C 函数指针为 read_intr</span></span><br><span class="line">	<span class="comment">// 因为硬盘中断处理程序每次调用 do_hd 时都会将该函数指针置 NULL。参见 system_call.s</span></span><br><span class="line">	<span class="keyword">if</span> (--CURRENT-&gt;nr_sectors) &#123;</span><br><span class="line">		do_hd = &amp;read_intr;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	end_request(<span class="number">1</span>);		</span><br><span class="line">	do_hd_request();	<span class="comment">// 执行其它硬盘请求操作（因为同一设备现在可能有多个请求项）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> port_read(port,buf,nr) \</span></span><br><span class="line">__asm__(<span class="string">"cld;rep;insw"</span>::<span class="string">"d"</span> (port),<span class="string">"D"</span> (buf),<span class="string">"c"</span> (nr):<span class="string">"cx"</span>,<span class="string">"di"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/blk_drv/blk.h ------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURRENT (blk_dev[MAJOR_NR].current_request)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/hdreg.h -----------------------</span></span><br><span class="line"><span class="comment">/* Hd controller regs. Ref: IBM AT Bios-listing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_DATA		0x1f0	<span class="comment">/* _CTL when writing */</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>AT 硬盘控制器寄存器端口</strong><br>上面程序 port_read 函数涉及到的 <code>AT 硬盘控制器寄存器端口</code>有如下这些：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/hdreg.h -----------------------</span></span><br><span class="line"><span class="comment">/* Hd controller regs. Ref: IBM AT Bios-listing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_DATA		0x1f0	<span class="comment">/* _CTL when writing */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_ERROR		0x1f1	<span class="comment">/* see err-bits */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_NSECTOR	0x1f2	<span class="comment">/* nr of sectors to read/write */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_SECTOR	0x1f3	<span class="comment">/* starting sector */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_LCYL		0x1f4	<span class="comment">/* starting cylinder */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_HCYL		0x1f5	<span class="comment">/* high byte of starting cyl */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_CURRENT	0x1f6	<span class="comment">/* 101dhhhh , d=drive, hhhh=head */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_STATUS	0x1f7	<span class="comment">/* see status-bits */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_PRECOMP HD_ERROR	<span class="comment">/* same io address, read=error, write=precomp */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_COMMAND HD_STATUS	<span class="comment">/* same io address, read=status, write=cmd */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD_CMD		0x3f6</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这些端口可用图表示如下：<br><img src="/images/os/linux-kenel-0.11/process-one/part3/AT硬盘控制器寄存器端口及作用.png" alt>图片来源：《Linux 内核完全注释》  </p>
<p>其中，<code>数据寄存器（HD_DATA，0x1f0）</code>是一对高速 PIO 数据传输器，用于扇区读、写和磁道格式化操作。CPU 通过该数据寄存器向硬盘写入或从硬盘读出 1 个扇区的数据，也即要使用命令 <code>rep outsw</code> 或 <code>rep insw</code> 重复读/写 cx = 256 字。</p>
<ul>
<li><p>读取数据流方向：<code>read_intr -&gt; hd_out -&gt; do_hd_request -&gt; add_request -&gt; make_request -&gt; ll_rw_block -&gt; bread</code>。</p>
</li>
<li><p><strong>read_intr 读取完 512 字节就返回了，也即中断返回。接下来接着进程 0 被硬盘中断中断的地方（pause、sys_pause、schedule、switch_to(0)）继续执行。</strong></p>
</li>
</ul>
<ul>
<li>如此反复，最终将引导块完整读入内存缓冲区的缓冲块。</li>
</ul>
<h3 id="调用-end-request"><a href="#调用-end-request" class="headerlink" title="调用 end_request"></a><strong>调用 end_request</strong></h3><p>此时，所有数据已经读取完毕，开始执行 end_request 函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/blk_drv/hd.c -------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_intr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	.....</span><br><span class="line">	<span class="comment">// 此时，所有数据已经读取完毕，开始执行 end_request</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果再次读出的扇区数量还没有读完，则再次置硬盘调用 C 函数指针为 read_intr</span></span><br><span class="line">	<span class="comment">// 因为硬盘中断处理程序每次调用 do_hd 时都会将该函数指针置 NULL。参见 system_call.s</span></span><br><span class="line">	<span class="keyword">if</span> (--CURRENT-&gt;nr_sectors) &#123;</span><br><span class="line">		do_hd = &amp;read_intr;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	end_request(<span class="number">1</span>);		</span><br><span class="line">	do_hd_request();	<span class="comment">// 执行其它硬盘请求操作（因为同一设备现在可能有多个请求项）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/blk_drv/blk.h ------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURRENT (blk_dev[MAJOR_NR].current_request)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">wait_for_request</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">end_request</span><span class="params">(<span class="keyword">int</span> uptodate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DEVICE_OFF(CURRENT-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (CURRENT-&gt;bh) &#123;</span><br><span class="line">		CURRENT-&gt;bh-&gt;b_uptodate = uptodate;	<span class="comment">// 表示数据已更新</span></span><br><span class="line">		unlock_buffer(CURRENT-&gt;bh);		<span class="comment">// 为缓冲块解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!uptodate) &#123;</span><br><span class="line">		printk(DEVICE_NAME <span class="string">" I/O error\n\r"</span>);</span><br><span class="line">		printk(<span class="string">"dev %04x, block %d\n\r"</span>,CURRENT-&gt;dev,</span><br><span class="line">			CURRENT-&gt;bh-&gt;b_blocknr);</span><br><span class="line">	&#125;</span><br><span class="line">	wake_up(&amp;CURRENT-&gt;waiting);	<span class="comment">// 唤醒等待该请求项的任务</span></span><br><span class="line">	wake_up(&amp;wait_for_request);	<span class="comment">// 唤醒等待请求的任务</span></span><br><span class="line">	CURRENT-&gt;dev = <span class="number">-1</span>;		<span class="comment">// 释放该请求项</span></span><br><span class="line">	CURRENT = CURRENT-&gt;next;	<span class="comment">// 从请求项链表中删除该请求项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/blk_drv/ll_rw_block.c ----------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unlock_buffer</span><span class="params">(struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!bh-&gt;b_lock)</span><br><span class="line">		printk(<span class="string">"ll_rw_block.c: buffer not locked\n\r"</span>);</span><br><span class="line">	bh-&gt;b_lock = <span class="number">0</span>;</span><br><span class="line">	wake_up(&amp;bh-&gt;b_wait);	<span class="comment">// 唤醒等待该缓冲块解锁的任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sched.c ------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">		(**p).state=<span class="number">0</span>;	<span class="comment">// 将任务设为就绪态</span></span><br><span class="line">		*p=<span class="literal">NULL</span>;	<span class="comment">// </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/sched.h -----------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_ZOMBIE		3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED		4</span></span><br></pre></td></tr></table></figure></p>
<p>需要<strong>注意</strong>的是，执行完 end_request 函数还会再次执行 do_hd_request 函数，以执行其它硬盘请求操作（因为同一设备现在可能有多个任务请求）。一个样例如下图所示：<br><img src="/images/os/linux-kenel-0.11/process-one/part3/处理请求项队列的情景.png" alt>图片来源：《Linux 内核设计的艺术》  </p>
<p>不过在这里，因为现在只有进程 1 有硬盘请求操作，所以一旦进程 1 请求完毕，就没有其他任务的硬盘请求操作了。</p>
<h3 id="切换到进程-1"><a href="#切换到进程-1" class="headerlink" title="切换到进程 1"></a><strong>切换到进程 1</strong></h3><p>read_intr 读取完所有数据（1024B，分两次读）就返回了，也即中断返回。接下来接着进程 0 被硬盘中断中断的地方（pause、sys_pause、schedule、switch_to(0)）继续执行。进程 0 通过 for(;;) 循环，迟早会执行到 schedule 函数。而此时，进程 0 处于 TASK_INTERRUPTIBLE 状态，进程 1 处于就绪态 TASK_RUNNING。所以一旦进程 0 执行到 schedule 函数，就会切换到进程 1。</p>
<p>在从进程 1 切换到进程 0 的时候，进程 1 的 TSS 会保存当时进程 1 运行时的寄存器的值，所以切换回进程 1 的时候便可以根据 TSS 来恢复当时进程 1 运行时的场景，即从 “cmpl %%ecx,_last_task_used_math\n\t” 这一句开始执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched.h -----------------------</span></span><br><span class="line"><span class="comment">// 输入：%0 - 存放新 TSS 的偏移地址（*&amp;__tmp.a），%1 - 存放新 TSS 的段选择符（子）（*&amp;__tmp.b）</span></span><br><span class="line"><span class="comment">//	dx - 新任务 n 的段选择符（子），ecx - 新任务指针 task[n]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(n) &#123;\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">long</span> a,b;&#125; __tmp; \		<span class="comment">// 为 ljmp 的 cs、eip 准备的数据结构</span></span><br><span class="line">__asm__(<span class="string">"cmpl %%ecx,_current\n\t"</span> \	<span class="comment">// 任务 n 是当前任务吗？（current = task[n]?）</span></span><br><span class="line">	<span class="string">"je 1f\n\t"</span> \			<span class="comment">// 如果是就不用切换任务了</span></span><br><span class="line">	<span class="string">"movw %%dx,%1\n\t"</span> \		<span class="comment">// 将新任务的选择子 =&gt; *&amp;__tmp.b</span></span><br><span class="line">	<span class="string">"xchgl %%ecx,_current\n\t"</span> \	<span class="comment">// current = task[n]；ecx = 被切换的任务</span></span><br><span class="line">	<span class="string">"ljmp %0\n\t"</span> \			<span class="comment">// 执行长跳至 *&amp;__tmp，造成任务切换</span></span><br><span class="line">					<span class="comment">// 执行任务切换回来后才会继续执行下面的语句</span></span><br><span class="line">	<span class="string">"cmpl %%ecx,_last_task_used_math\n\t"</span> \	<span class="comment">// 新任务上次使用过协处理器吗？</span></span><br><span class="line">	<span class="string">"jne 1f\n\t"</span> \			<span class="comment">// 没有则跳转，退出</span></span><br><span class="line">	<span class="string">"clts\n"</span> \			<span class="comment">// 新任务上次使用过协处理器，清 CR0 的 TS 标志</span></span><br><span class="line">	<span class="string">"1:"</span> \</span><br><span class="line">	::<span class="string">"m"</span> (*&amp;__tmp.a),<span class="string">"m"</span> (*&amp;__tmp.b), \</span><br><span class="line">	<span class="string">"d"</span> (_TSS(n)),<span class="string">"c"</span> ((<span class="keyword">long</span>) task[n])); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="返回-bread"><a href="#返回-bread" class="headerlink" title="返回 bread"></a><strong>返回 bread</strong></h3><p>切换回进程 1 之后，根据进程 1 TSS 保存的寄存器值，（参考本文“切换到进程 0 前的进程 1 的执行过程”）执行路线是：switch_to(0) -&gt; sleep_on -&gt; wait_on_buffer -&gt; bread：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/buffer.c ---------------------------------</span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">bread</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	wait_on_buffer(bh);</span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate)	<span class="comment">// 硬盘引导块对应的缓冲块数据已更新</span></span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="返回-sys-setup"><a href="#返回-sys-setup" class="headerlink" title="返回 sys_setup"></a><strong>返回 sys_setup</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kenel/blk_drv/hd.c --------------------------</span></span><br><span class="line"><span class="comment">// 定义硬盘分区结构。给出每个分区的物理起始扇区号、分区的扇区总数</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> start_sect;</span><br><span class="line">	<span class="keyword">long</span> nr_sects;</span><br><span class="line">&#125; hd[<span class="number">5</span>*MAX_HD]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_setup</span><span class="params">(<span class="keyword">void</span> * BIOS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;</span><br><span class="line">			printk(<span class="string">"Unable to read partition table of drive %d\n\r"</span>,</span><br><span class="line">				drive);</span><br><span class="line">			panic(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 请参考博文：Linux 内核学习笔记：预备知识之“硬盘基础知识”</span></span><br><span class="line">		<span class="comment">// 链接：http://xiehongfeng100.github.io/2016/01/29/linux-kenel-0-11-topic-necessary-preparation-part8/</span></span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_data[<span class="number">510</span>] != <span class="number">0x55</span> || (<span class="keyword">unsigned</span> <span class="keyword">char</span>)	<span class="comment">// 0x55,0xAA 是有效引导扇区的标志</span></span><br><span class="line">		    bh-&gt;b_data[<span class="number">511</span>] != <span class="number">0xAA</span>) &#123;</span><br><span class="line">			printk(<span class="string">"Bad partition table on drive %d\n\r"</span>,drive);</span><br><span class="line">			panic(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		p = <span class="number">0x1BE</span> + (<span class="keyword">void</span> *)bh-&gt;b_data;	<span class="comment">// 根据引导块中的分区表信息设置分区结构数组 hd[]</span></span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++,p++) &#123;</span><br><span class="line">			hd[i+<span class="number">5</span>*drive].start_sect = p-&gt;start_sect;</span><br><span class="line">			hd[i+<span class="number">5</span>*drive].nr_sects = p-&gt;nr_sects;</span><br><span class="line">		&#125;</span><br><span class="line">		brelse(bh);	<span class="comment">// 释放缓冲块（引用计数减 1）</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (NR_HD)</span><br><span class="line">		printk(<span class="string">"Partition table%s ok.\n\r"</span>,(NR_HD&gt;<span class="number">1</span>)?<span class="string">"s"</span>:<span class="string">""</span>);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/hdreg.h -----------------------</span></span><br><span class="line"><span class="comment">// 请参考博文：Linux 内核学习笔记：预备知识之“硬盘基础知识”关于“分区表”部分</span></span><br><span class="line"><span class="comment">// 链接：http://xiehongfeng100.github.io/2016/01/29/linux-kenel-0-11-topic-necessary-preparation-part8/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partition</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> boot_ind;		<span class="comment">/* 0x80 - active (unused) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> head;		<span class="comment">/* ? */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sector;		<span class="comment">/* ? */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> cyl;		<span class="comment">/* ? */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sys_ind;		<span class="comment">/* ? */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> end_head;		<span class="comment">/* ? */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> end_sector;	<span class="comment">/* ? */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> end_cyl;		<span class="comment">/* ? */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> start_sect;	<span class="comment">/* starting sector counting from 0 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nr_sects;		<span class="comment">/* nr of sectors in partition */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="进程-1-格式化虚拟盘并更换根设备为虚拟盘"><a href="#进程-1-格式化虚拟盘并更换根设备为虚拟盘" class="headerlink" title="进程 1 格式化虚拟盘并更换根设备为虚拟盘"></a><strong>进程 1 格式化虚拟盘并更换根设备为虚拟盘</strong></h3><p>以防博文过长，接下来内容请见续篇。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/02/29/linux-kenel-0-11-topic-process-one-part4/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Linux 内核学习笔记：进程 1 的创建及执行（第 4 部分） —— 加载根文件系统
        
      </div>
    </a>
  
  
    <a href="/2016/02/26/linux-kenel-0-11-topic-process-one-part2/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Linux 内核学习笔记：进程 1 的创建及执行（第 2 部分） —— 任务调度</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>







      <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>

<script>
var gitalk = new Gitalk({
  clientID: '64c19d7f57bebbb343c4',
  clientSecret: '287daeba39e73fdde92f24540c9f3c0fd5238512',
  repo: 'BlogComments',
  owner: 'xiemax100',
  admin: ['xiemax100'],
  id: md5(window.location.pathname),
  distractionFreeMode: true
})

gitalk.render('gitalk-container')
</script>






    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#调用-sys-setup"><span class="toc-number">1.</span> <span class="toc-text">调用 sys_setup</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程-1-设置硬盘的-hd-info"><span class="toc-number">1.1.</span> <span class="toc-text">进程 1 设置硬盘的 hd_info</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读取硬盘引导块到缓冲区"><span class="toc-number">1.2.</span> <span class="toc-text">读取硬盘引导块到缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-bread"><span class="toc-number">1.2.1.</span> <span class="toc-text">调用 bread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-getblk"><span class="toc-number">1.2.2.</span> <span class="toc-text">调用 getblk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-ll-rw-block"><span class="toc-number">1.2.3.</span> <span class="toc-text">调用 ll_rw_block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-make-request"><span class="toc-number">1.2.4.</span> <span class="toc-text">调用 make_request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-add-request"><span class="toc-number">1.2.5.</span> <span class="toc-text">调用 add_request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-do-hd-request"><span class="toc-number">1.2.6.</span> <span class="toc-text">调用 do_hd_request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-hd-out"><span class="toc-number">1.2.7.</span> <span class="toc-text">调用 hd_out</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题外：硬盘"><span class="toc-number">1.2.8.</span> <span class="toc-text">题外：硬盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切换到进程-0"><span class="toc-number">1.2.9.</span> <span class="toc-text">切换到进程 0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#硬盘中断"><span class="toc-number">1.2.10.</span> <span class="toc-text">硬盘中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-read-intr"><span class="toc-number">1.2.11.</span> <span class="toc-text">调用 read_intr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-end-request"><span class="toc-number">1.2.12.</span> <span class="toc-text">调用 end_request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切换到进程-1"><span class="toc-number">1.2.13.</span> <span class="toc-text">切换到进程 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#返回-bread"><span class="toc-number">1.2.14.</span> <span class="toc-text">返回 bread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#返回-sys-setup"><span class="toc-number">1.2.15.</span> <span class="toc-text">返回 sys_setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程-1-格式化虚拟盘并更换根设备为虚拟盘"><span class="toc-number">1.2.16.</span> <span class="toc-text">进程 1 格式化虚拟盘并更换根设备为虚拟盘</span></a></li></ol></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var toc_button = document.getElementById("tocButton");
    var toc_div = document.getElementById("toc");
    toc_button.onclick=function() {
        if (toc_div.style.display == "none") {
            toc_div.style.display = "block";
            toc_button.value = "隐藏目录";
            document.getElementById("switch-btn").style.display = "none";
            document.getElementById("switch-area").style.display = "none";
        }
        else {
            toc_div.style.display = "none";
            toc_button.value = "显示目录";
            document.getElementById("switch-btn").style.display = "block";
            document.getElementById("switch-area").style.display = "block";
        }
    }

    if ($(".toc").length < 1) {
        $("#toc").css("display","none");
        $("#tocButton").css("display","none");
        $(".switch-btn").css("display","block");
        $(".switch-area").css("display","block");
    }
</script>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 Max
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>