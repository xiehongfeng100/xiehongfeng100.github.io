<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Linux 内核学习笔记：文件操作 | Max&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这两天把之前写的博文回顾了一遍，所以才迟迟没有写新的博文。这篇博文主要关注文件系统相关的操作（如打开、关闭文件等）。关于文件系统基础知识，请先阅读以下两篇博文：Linux 内核学习笔记：进程 1 的创建及执行（第 4 部分）Linux 内核学习笔记：进程 2 的创建及执行（第 1 部分）   安装文件系统在此之前，我们已经安装好了根文件系统。安装其他文件系统就是在根文件系统的基础上，把逻辑设备（如">
<meta name="keywords" content="Linux,内核,文件系统">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内核学习笔记：文件操作">
<meta property="og:url" content="http://xiehongfeng100.github.io/2016/03/09/linux-kenel-0-11-topic-file-operation/index.html">
<meta property="og:site_name" content="Max&#39;s Blog">
<meta property="og:description" content="这两天把之前写的博文回顾了一遍，所以才迟迟没有写新的博文。这篇博文主要关注文件系统相关的操作（如打开、关闭文件等）。关于文件系统基础知识，请先阅读以下两篇博文：Linux 内核学习笔记：进程 1 的创建及执行（第 4 部分）Linux 内核学习笔记：进程 2 的创建及执行（第 1 部分）   安装文件系统在此之前，我们已经安装好了根文件系统。安装其他文件系统就是在根文件系统的基础上，把逻辑设备（如">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/fs/filp[20]file_table[64]inode_table[32]三者之间的关系.png">
<meta property="og:updated_time" content="2019-05-01T06:53:11.584Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux 内核学习笔记：文件操作">
<meta name="twitter:description" content="这两天把之前写的博文回顾了一遍，所以才迟迟没有写新的博文。这篇博文主要关注文件系统相关的操作（如打开、关闭文件等）。关于文件系统基础知识，请先阅读以下两篇博文：Linux 内核学习笔记：进程 1 的创建及执行（第 4 部分）Linux 内核学习笔记：进程 2 的创建及执行（第 1 部分）   安装文件系统在此之前，我们已经安装好了根文件系统。安装其他文件系统就是在根文件系统的基础上，把逻辑设备（如">
<meta name="twitter:image" content="http://xiehongfeng100.github.io/images/os/linux-kenel-0.11/fs/filp[20]file_table[64]inode_table[32]三者之间的关系.png">
  
    <link rel="alternative" href="/atom.xml" title="Max&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="img/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/author.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Max</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Stay hungry, stay foolish.</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/读书">读书</a></li>
				        
							<li><a href="/tags/翻译">翻译</a></li>
				        
							<li><a href="/categories/网络">网络</a></li>
				        
							<li><a href="/categories/并发">并发</a></li>
				        
							<li><a href="/categories/安全">安全</a></li>
				        
							<li><a href="/categories/运维">运维</a></li>
				        
							<li><a href="/categories/数据库">数据库</a></li>
				        
							<li><a href="/categories/云计算">云计算</a></li>
				        
							<li><a href="/categories/编程语言">编程语言</a></li>
				        
							<li><a href="/categories/操作系统">操作系统</a></li>
				        
							<li><a href="/categories/机器学习">机器学习</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/xiehongfeng100" title="github">github</a>
					        
								<a class="linkedin" target="_blank" href="http://cn.linkedin.com/in/xiehongfeng100" title="linkedin">linkedin</a>
					        
								<a class="mail" target="_blank" href="mailto:xiehongfeng100@hotmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/tmp/" style="font-size: 10px;">/tmp</a> <a href="/tags/AT-T/" style="font-size: 10px;">AT&T</a> <a href="/tags/Affin/" style="font-size: 10px;">Affin</a> <a href="/tags/Alembic/" style="font-size: 10px;">Alembic</a> <a href="/tags/B-树/" style="font-size: 10px;">B+ 树</a> <a href="/tags/BIOS/" style="font-size: 10px;">BIOS</a> <a href="/tags/Buffer-Pool/" style="font-size: 10px;">Buffer Pool</a> <a href="/tags/C-C/" style="font-size: 16.67px;">C/C++</a> <a href="/tags/CA/" style="font-size: 10px;">CA</a> <a href="/tags/CBOW/" style="font-size: 10px;">CBOW</a> <a href="/tags/CNN/" style="font-size: 10.83px;">CNN</a> <a href="/tags/DHCP/" style="font-size: 10px;">DHCP</a> <a href="/tags/Decorator/" style="font-size: 10px;">Decorator</a> <a href="/tags/Django/" style="font-size: 10px;">Django</a> <a href="/tags/Dnsmasq/" style="font-size: 10px;">Dnsmasq</a> <a href="/tags/ELF/" style="font-size: 10px;">ELF</a> <a href="/tags/ELK/" style="font-size: 10px;">ELK</a> <a href="/tags/Elasticsearch/" style="font-size: 11.67px;">Elasticsearch</a> <a href="/tags/GCC/" style="font-size: 10px;">GCC</a> <a href="/tags/HBR/" style="font-size: 10px;">HBR</a> <a href="/tags/IO-Multiplexing/" style="font-size: 11.67px;">IO Multiplexing</a> <a href="/tags/IPTables/" style="font-size: 10px;">IPTables</a> <a href="/tags/Immunity-Debugger/" style="font-size: 10px;">Immunity Debugger</a> <a href="/tags/InnoDB/" style="font-size: 15.83px;">InnoDB</a> <a href="/tags/KD-Tree/" style="font-size: 10.83px;">KD-Tree</a> <a href="/tags/KNN/" style="font-size: 10px;">KNN</a> <a href="/tags/KVM/" style="font-size: 10px;">KVM</a> <a href="/tags/Kali-Linux/" style="font-size: 10px;">Kali Linux</a> <a href="/tags/Keras/" style="font-size: 10px;">Keras</a> <a href="/tags/Keystone/" style="font-size: 13.33px;">Keystone</a> <a href="/tags/Kibana/" style="font-size: 10px;">Kibana</a> <a href="/tags/Lemmatization/" style="font-size: 10px;">Lemmatization</a> <a href="/tags/Libvirt/" style="font-size: 10.83px;">Libvirt</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/LinuxBridge/" style="font-size: 11.67px;">LinuxBridge</a> <a href="/tags/Logging/" style="font-size: 10px;">Logging</a> <a href="/tags/Logstash/" style="font-size: 10px;">Logstash</a> <a href="/tags/MRO/" style="font-size: 10px;">MRO</a> <a href="/tags/Metasploit-Framwork/" style="font-size: 10px;">Metasploit Framwork</a> <a href="/tags/MySQL/" style="font-size: 16.67px;">MySQL</a> <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/Namespace/" style="font-size: 10px;">Namespace</a> <a href="/tags/Neo4J/" style="font-size: 10.83px;">Neo4J</a> <a href="/tags/Neutron/" style="font-size: 13.33px;">Neutron</a> <a href="/tags/Nova/" style="font-size: 14.17px;">Nova</a> <a href="/tags/OpenStack/" style="font-size: 17.5px;">OpenStack</a> <a href="/tags/OpenVSwitch/" style="font-size: 10px;">OpenVSwitch</a> <a href="/tags/PKI/" style="font-size: 10.83px;">PKI</a> <a href="/tags/PasteDeploy/" style="font-size: 10.83px;">PasteDeploy</a> <a href="/tags/Policy/" style="font-size: 10px;">Policy</a> <a href="/tags/Python/" style="font-size: 18.33px;">Python</a> <a href="/tags/QEMU/" style="font-size: 10px;">QEMU</a> <a href="/tags/RBAC/" style="font-size: 10px;">RBAC</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/Redo-Log/" style="font-size: 10px;">Redo Log</a> <a href="/tags/SQLAlchemy-Migrate/" style="font-size: 10px;">SQLAlchemy-Migrate</a> <a href="/tags/SSL/" style="font-size: 10px;">SSL</a> <a href="/tags/Sigmoid/" style="font-size: 10px;">Sigmoid</a> <a href="/tags/Skip-Gram/" style="font-size: 10px;">Skip-Gram</a> <a href="/tags/Socket/" style="font-size: 10px;">Socket</a> <a href="/tags/Stop-Words/" style="font-size: 10px;">Stop Words</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Tap/" style="font-size: 10.83px;">Tap</a> <a href="/tags/Token/" style="font-size: 11.67px;">Token</a> <a href="/tags/Tokenization/" style="font-size: 10px;">Tokenization</a> <a href="/tags/Trampolining/" style="font-size: 10px;">Trampolining</a> <a href="/tags/Tun/" style="font-size: 10.83px;">Tun</a> <a href="/tags/Tunnel/" style="font-size: 10px;">Tunnel</a> <a href="/tags/UUID/" style="font-size: 10px;">UUID</a> <a href="/tags/Undo-Log/" style="font-size: 10px;">Undo Log</a> <a href="/tags/VNC/" style="font-size: 10px;">VNC</a> <a href="/tags/VPN/" style="font-size: 10px;">VPN</a> <a href="/tags/Veth/" style="font-size: 11.67px;">Veth</a> <a href="/tags/VirtualBox/" style="font-size: 10px;">VirtualBox</a> <a href="/tags/Vlan/" style="font-size: 10px;">Vlan</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/WSGI/" style="font-size: 13.33px;">WSGI</a> <a href="/tags/Webob/" style="font-size: 10px;">Webob</a> <a href="/tags/Word2Vec/" style="font-size: 10.83px;">Word2Vec</a> <a href="/tags/Yelper/" style="font-size: 15px;">Yelper</a> <a href="/tags/bootsect/" style="font-size: 10px;">bootsect</a> <a href="/tags/cookiecutter/" style="font-size: 10px;">cookiecutter</a> <a href="/tags/delete/" style="font-size: 10px;">delete</a> <a href="/tags/dnsmasq/" style="font-size: 10px;">dnsmasq</a> <a href="/tags/entry-points/" style="font-size: 10px;">entry_points</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/fork/" style="font-size: 10px;">fork</a> <a href="/tags/head/" style="font-size: 10px;">head</a> <a href="/tags/inode/" style="font-size: 10px;">inode</a> <a href="/tags/malloc/" style="font-size: 10px;">malloc</a> <a href="/tags/mona/" style="font-size: 10px;">mona</a> <a href="/tags/new/" style="font-size: 10px;">new</a> <a href="/tags/property/" style="font-size: 10px;">property</a> <a href="/tags/read/" style="font-size: 10px;">read</a> <a href="/tags/routes/" style="font-size: 10px;">routes</a> <a href="/tags/select/" style="font-size: 10px;">select</a> <a href="/tags/setup/" style="font-size: 10px;">setup</a> <a href="/tags/setuptools/" style="font-size: 10px;">setuptools</a> <a href="/tags/shell/" style="font-size: 10.83px;">shell</a> <a href="/tags/stevedore/" style="font-size: 10px;">stevedore</a> <a href="/tags/string/" style="font-size: 10px;">string</a> <a href="/tags/tcpdump/" style="font-size: 10px;">tcpdump</a> <a href="/tags/uWSGI/" style="font-size: 10px;">uWSGI</a> <a href="/tags/update-进程/" style="font-size: 10px;">update 进程</a> <a href="/tags/write/" style="font-size: 10px;">write</a> <a href="/tags/wsgiref/" style="font-size: 10px;">wsgiref</a> <a href="/tags/yield/" style="font-size: 14.17px;">yield</a> <a href="/tags/中断/" style="font-size: 10.83px;">中断</a> <a href="/tags/事务/" style="font-size: 13.33px;">事务</a> <a href="/tags/任务调度/" style="font-size: 10px;">任务调度</a> <a href="/tags/传记/" style="font-size: 10.83px;">传记</a> <a href="/tags/信号/" style="font-size: 10px;">信号</a> <a href="/tags/信号量/" style="font-size: 10px;">信号量</a> <a href="/tags/内存对齐/" style="font-size: 10px;">内存对齐</a> <a href="/tags/内存映射-I-O/" style="font-size: 10px;">内存映射 I/O</a> <a href="/tags/内存规划/" style="font-size: 10px;">内存规划</a> <a href="/tags/内核/" style="font-size: 19.17px;">内核</a> <a href="/tags/内核栈/" style="font-size: 10px;">内核栈</a> <a href="/tags/分页/" style="font-size: 10px;">分页</a> <a href="/tags/加密/" style="font-size: 10.83px;">加密</a> <a href="/tags/加载/" style="font-size: 10.83px;">加载</a> <a href="/tags/协程/" style="font-size: 13.33px;">协程</a> <a href="/tags/可执行目标文件/" style="font-size: 10.83px;">可执行目标文件</a> <a href="/tags/可重定位目标文件/" style="font-size: 10px;">可重定位目标文件</a> <a href="/tags/同步/" style="font-size: 10px;">同步</a> <a href="/tags/商业/" style="font-size: 11.67px;">商业</a> <a href="/tags/地心坐标系/" style="font-size: 10px;">地心坐标系</a> <a href="/tags/多线程/" style="font-size: 10.83px;">多线程</a> <a href="/tags/多进程/" style="font-size: 10px;">多进程</a> <a href="/tags/字符串/" style="font-size: 10px;">字符串</a> <a href="/tags/存储器/" style="font-size: 10.83px;">存储器</a> <a href="/tags/宏/" style="font-size: 10px;">宏</a> <a href="/tags/寄存器/" style="font-size: 10px;">寄存器</a> <a href="/tags/开发环境/" style="font-size: 10px;">开发环境</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/异步/" style="font-size: 10px;">异步</a> <a href="/tags/引导块/" style="font-size: 10px;">引导块</a> <a href="/tags/引导程序/" style="font-size: 12.5px;">引导程序</a> <a href="/tags/归一化/" style="font-size: 10px;">归一化</a> <a href="/tags/微处理器/" style="font-size: 13.33px;">微处理器</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/情感分析/" style="font-size: 10px;">情感分析</a> <a href="/tags/扩容/" style="font-size: 10px;">扩容</a> <a href="/tags/指令集/" style="font-size: 10px;">指令集</a> <a href="/tags/指针/" style="font-size: 12.5px;">指针</a> <a href="/tags/数字签名/" style="font-size: 10px;">数字签名</a> <a href="/tags/数字证书/" style="font-size: 10px;">数字证书</a> <a href="/tags/整数/" style="font-size: 10px;">整数</a> <a href="/tags/文件系统/" style="font-size: 12.5px;">文件系统</a> <a href="/tags/时钟/" style="font-size: 10px;">时钟</a> <a href="/tags/时钟中断/" style="font-size: 10px;">时钟中断</a> <a href="/tags/时间衰减函数/" style="font-size: 10px;">时间衰减函数</a> <a href="/tags/权限/" style="font-size: 10px;">权限</a> <a href="/tags/标准输入/" style="font-size: 10px;">标准输入</a> <a href="/tags/标准输出/" style="font-size: 10px;">标准输出</a> <a href="/tags/标准错误输出/" style="font-size: 10px;">标准错误输出</a> <a href="/tags/栈帧/" style="font-size: 10px;">栈帧</a> <a href="/tags/栈溢出/" style="font-size: 10px;">栈溢出</a> <a href="/tags/根设备/" style="font-size: 10px;">根设备</a> <a href="/tags/死锁/" style="font-size: 10px;">死锁</a> <a href="/tags/母板/" style="font-size: 10px;">母板</a> <a href="/tags/汇编/" style="font-size: 10px;">汇编</a> <a href="/tags/浮点数/" style="font-size: 10px;">浮点数</a> <a href="/tags/消息摘要/" style="font-size: 10px;">消息摘要</a> <a href="/tags/特权级/" style="font-size: 10px;">特权级</a> <a href="/tags/环境变量/" style="font-size: 10px;">环境变量</a> <a href="/tags/生成器/" style="font-size: 14.17px;">生成器</a> <a href="/tags/用户栈/" style="font-size: 10px;">用户栈</a> <a href="/tags/相似度/" style="font-size: 10.83px;">相似度</a> <a href="/tags/硬盘/" style="font-size: 12.5px;">硬盘</a> <a href="/tags/硬链接/" style="font-size: 10px;">硬链接</a> <a href="/tags/管道/" style="font-size: 10px;">管道</a> <a href="/tags/系统调用/" style="font-size: 10px;">系统调用</a> <a href="/tags/索引/" style="font-size: 10px;">索引</a> <a href="/tags/缓冲区/" style="font-size: 10.83px;">缓冲区</a> <a href="/tags/缓冲区溢出/" style="font-size: 10px;">缓冲区溢出</a> <a href="/tags/缺页中断/" style="font-size: 10px;">缺页中断</a> <a href="/tags/网络/" style="font-size: 13.33px;">网络</a> <a href="/tags/翻译/" style="font-size: 14.17px;">翻译</a> <a href="/tags/虚拟地址空间/" style="font-size: 10px;">虚拟地址空间</a> <a href="/tags/虚拟盘/" style="font-size: 10px;">虚拟盘</a> <a href="/tags/请求项/" style="font-size: 10px;">请求项</a> <a href="/tags/质数/" style="font-size: 10px;">质数</a> <a href="/tags/超级块/" style="font-size: 10px;">超级块</a> <a href="/tags/软盘/" style="font-size: 10px;">软盘</a> <a href="/tags/软链接/" style="font-size: 10px;">软链接</a> <a href="/tags/进程派生/" style="font-size: 10px;">进程派生</a> <a href="/tags/进程通信/" style="font-size: 10.83px;">进程通信</a> <a href="/tags/迭代器/" style="font-size: 10px;">迭代器</a> <a href="/tags/金融/" style="font-size: 10px;">金融</a> <a href="/tags/锁/" style="font-size: 10.83px;">锁</a> <a href="/tags/阻塞/" style="font-size: 10.83px;">阻塞</a> <a href="/tags/非阻塞/" style="font-size: 10.83px;">非阻塞</a> <a href="/tags/黑客/" style="font-size: 10px;">黑客</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">谢宏峰，毕业于暨南大学（2009 - 2013）、中国科学院（2013 - 2016），现就职于深信服科技，从事 OpenStack 开发。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Max</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/author.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Max</h1>
			</hgroup>
			
			<p class="header-subtitle">Stay hungry, stay foolish.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/读书">读书</a></li>
		        
					<li><a href="/tags/翻译">翻译</a></li>
		        
					<li><a href="/categories/网络">网络</a></li>
		        
					<li><a href="/categories/并发">并发</a></li>
		        
					<li><a href="/categories/安全">安全</a></li>
		        
					<li><a href="/categories/运维">运维</a></li>
		        
					<li><a href="/categories/数据库">数据库</a></li>
		        
					<li><a href="/categories/云计算">云计算</a></li>
		        
					<li><a href="/categories/编程语言">编程语言</a></li>
		        
					<li><a href="/categories/操作系统">操作系统</a></li>
		        
					<li><a href="/categories/机器学习">机器学习</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/xiehongfeng100" title="github">github</a>
			        
						<a class="linkedin" target="_blank" href="http://cn.linkedin.com/in/xiehongfeng100" title="linkedin">linkedin</a>
			        
						<a class="mail" target="_blank" href="mailto:xiehongfeng100@hotmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-linux-kenel-0-11-topic-file-operation" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/09/linux-kenel-0-11-topic-file-operation/" class="article-date">
  	<time datetime="2016-03-09T01:56:12.000Z" itemprop="datePublished">2016-03-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux 内核学习笔记：文件操作
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内核/">内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/文件系统/">文件系统</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/操作系统/">操作系统</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这两天把之前写的博文回顾了一遍，所以才迟迟没有写新的博文。这篇博文主要关注文件系统相关的操作（如打开、关闭文件等）。关于文件系统基础知识，请先阅读以下两篇博文：<br><a href="http://xiehongfeng100.github.io/2016/02/29/linux-kenel-0-11-topic-process-one-part4/">Linux 内核学习笔记：进程 1 的创建及执行（第 4 部分）</a><br><a href="http://xiehongfeng100.github.io/2016/03/02/linux-kenel-0-11-topic-process-two-part1/">Linux 内核学习笔记：进程 2 的创建及执行（第 1 部分）</a>  </p>
<h1 id="安装文件系统"><a href="#安装文件系统" class="headerlink" title="安装文件系统"></a><strong>安装文件系统</strong></h1><p>在此之前，我们已经<a href="http://xiehongfeng100.github.io/2016/02/29/linux-kenel-0-11-topic-process-one-part4/">安装好了根文件系统</a>。安装其他文件系统就是在根文件系统的基础上，把逻辑设备（如硬盘一个分区）上的文件系统安装到根文件系统上，使操作系统具备以文件的形式与该逻辑设备进行数据交互的能力。具体来说，就是<code>将该逻辑设备上的文件系统的根 i 节点，关联到根文件系统的某个 i 节点上。</code></p>
<p>实现文件系统安装的命令是 <code>mount</code>。如 “mount /dev/hd1 /mnt” 表示将设备 /dev/hd1 上的文件系统挂载在 /mn 目录文件下。shell 进程接到该命令后，会创建一个新进程，新进程调用 mount 命令，并最终映射到 sys_mount 系统调用函数。安装文件系统的工作就由 sys_mount 函数完成。</p>
<a id="more"></a>
<p><code>sys_mount</code> 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/super.c ----------------------------------</span></span><br><span class="line"><span class="comment">// dev_name：要挂载的设备文件</span></span><br><span class="line"><span class="comment">// dir_name：要挂载到的目录文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mount</span><span class="params">(<span class="keyword">char</span> * dev_name, <span class="keyword">char</span> * dir_name, <span class="keyword">int</span> rw_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dev_i</span>, * <span class="title">dir_i</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> dev;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步骤 1：获取设备文件设备号 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dev_i=namei(dev_name)))	<span class="comment">// 获取 /dev/hd1 设备文件 i 节点，其中</span></span><br><span class="line">					<span class="comment">// 涉及到为该 i 节点在 inode_table 申请一个空闲项</span></span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	dev = dev_i-&gt;i_zone[<span class="number">0</span>];		<span class="comment">// 通过 i 节点，获取设备号</span></span><br><span class="line">	<span class="keyword">if</span> (!S_ISBLK(dev_i-&gt;i_mode)) &#123;	<span class="comment">// 如果 /dev/hd1 设备文件不是块设备</span></span><br><span class="line">		iput(dev_i);		<span class="comment">// 就释放掉它的 i 节点</span></span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	iput(dev_i);	<span class="comment">// 释放掉它的 i 节点，实际就是将该 i 节点的引用计数减 1。不过 iput 函数做的还不止这些。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步骤 2：获取要挂载到的目录文件的 i 节点  —— 确定挂载点*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dir_i=namei(dir_name)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="keyword">if</span> (dir_i-&gt;i_count != <span class="number">1</span> || dir_i-&gt;i_num == ROOT_INO) &#123;	<span class="comment">// 确定 /mnt 的 i 节点只被引用过一次，而且不是根节点</span></span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!S_ISDIR(dir_i-&gt;i_mode)) &#123;	<span class="comment">// 确定 /mnt 确实是目录文件</span></span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步骤 3：读取设备文件的超级块 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(sb=read_super(dev))) &#123;	<span class="comment">// read_super 函数除了读取超级块，还挂接了 i 节点位图和逻辑块位图</span></span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;s_imount) &#123;	<span class="comment">// 确保 /dev/hd1 设备文件没有被安装在其他地方</span></span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dir_i-&gt;i_mount) &#123;	<span class="comment">// 确保 /mn 目录文件 i 节点没有安装过其他文件系统</span></span><br><span class="line">		iput(dir_i);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步骤 4：将设备文件挂载到根文件系统 */</span></span><br><span class="line"></span><br><span class="line">	sb-&gt;s_imount=dir_i;	<span class="comment">// 将超级块与（根文件系统）中的 /mn 目录文件 i 节点挂接</span></span><br><span class="line">	dir_i-&gt;i_mount=<span class="number">1</span>;	<span class="comment">// /mn 目录文件 i 节点已经挂载了其他文件系统</span></span><br><span class="line">	dir_i-&gt;i_dirt=<span class="number">1</span>;		<span class="comment">/* NOTE! we don't iput(dir_i) */</span>	<span class="comment">// /mn 目录文件 i 节点已被修改（意味着需要同步到外设）</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;			<span class="comment">/* we do that in umount */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="打开和读取文件"><a href="#打开和读取文件" class="headerlink" title="打开和读取文件"></a><strong>打开和读取文件</strong></h1><p>打开和读取文件实例来自《Linux 内核设计的艺术》：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.txt</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">12000</span>];</span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">"/mnt/user/user1/user2/hello.txt"</span>, O_RDWR, <span class="number">0644</span>);</span><br><span class="line">	<span class="comment">// 读取文件</span></span><br><span class="line">	<span class="keyword">int</span> size = read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a><strong>打开文件</strong></h2><p>打开文件是拟人化的表述，在操作系统中就是确定进程操作哪个文件。打开文件过程涉及到 3 个重要数据结构：  </p>
<ul>
<li>进程的 <code>*filp[20]</code>：内核通过 struct file *filp[20] 掌控一个进程可以打开的文件，即可以打开多个不同的文件，也可以同一个文件多次打开，每打开一个文件（不论是否是同一个文件），就要在 *file[20] 中占用一项（如 hello.txt 文件被一个进程打开两次，就要在 *filp[20] 中占用两项）记录指针，所以，一个进程可以同时打开的文件次数不能超过 20 次。</li>
<li>内核的 <code>file_table[64]</code>：内核中的 file_table[64] 是管理所有进程打开文件的数据结构，不但记录了不同的进程打开不同的文件，也记录了不同的进程打开同一文件，甚至纪录了同一进程多次打开同一个文件。与 *filp[20] 类似，只要打开一次文件，就要在 file_table[64] 中记录。</li>
<li>内核的 <code>inode_table[32]</code>：文件的 i 节点是记载文件属性的最关键的数据结构。在操作系统中 i 节点和文件是一一对应的，找到 i 节点就能够唯一确定文件。内核通过 inode_table[32] 掌控正在使用的文件 i 节点，每个被使用的文件 i 节点都要记录在其中。</li>
</ul>
<p>打开文件的本质就是要建立 *filp[20、file_table[64]、inode_table[32] 三者之间的关系：<br><img src="/images/os/linux-kenel-0.11/fs/filp[20]file_table[64]inode_table[32]三者之间的关系.png" alt>图片来源：《Linux 内核设计的艺术》  </p>
<p><strong><code>打开文件过程</code></strong>：  </p>
<ul>
<li>第 1 步：将用户进程 task_struct 中的 *filp[20] 与内核中的 file_table[64] 相挂接</li>
<li>第 2 步：以用户给定的路径名（/mnt/user/user1/user2/hello.txt）为线索，找到 hello.txt 文件的 i 节点（登记到 inode_table[32]）</li>
<li>第 3 步：将 hello.txt 的 i 节点在 file_table[64] 进行登记</li>
</ul>
<p>详细过程请参考之前博文 <a href="http://xiehongfeng100.github.io/2016/03/02/linux-kenel-0-11-topic-process-two-part1/">Linux 内核学习笔记：进程 2 的创建及执行（第 1 部分）</a>。</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a><strong>读取文件</strong></h2><p>读文件就是从进程“已打开的文件”中读取数据，读文件由 read 函数完成。read 函数最终映射到 sys_read 函数去执行。</p>
<p>sys_read 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/read_write.c -----------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (!count)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	verify_area(buf,count);	<span class="comment">// 对 buf 所在的页面的属性进行验证，如果该页面是只读的，则复制该页面</span></span><br><span class="line">	inode = file-&gt;f_inode;</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_pipe)	<span class="comment">// 管道文件</span></span><br><span class="line">		<span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">1</span>)?read_pipe(inode,buf,count):-EIO;</span><br><span class="line">	<span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))	<span class="comment">// 字符型文件</span></span><br><span class="line">		<span class="keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))	<span class="comment">// 块设备文件</span></span><br><span class="line">		<span class="keyword">return</span> block_read(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)</span><br><span class="line">			count = inode-&gt;i_size - file-&gt;f_pos;</span><br><span class="line">		<span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> file_read(inode,file,buf,count);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">"(Read)inode-&gt;i_mode=%06o\n\r"</span>,inode-&gt;i_mode);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="verify-area-函数"><a href="#verify-area-函数" class="headerlink" title="verify_area 函数"></a><strong>verify_area 函数</strong></h3><p>verify_area 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fork.c -------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">verify_area</span><span class="params">(<span class="keyword">void</span> * addr,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">	start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">	size += start &amp; <span class="number">0xfff</span>;	<span class="comment">// 调整验证区域。这一句保证了原 size 大小的区域会被验证到，因为下句会对地址低 12 位置 0</span></span><br><span class="line">	start &amp;= <span class="number">0xfffff000</span>;	<span class="comment">// start 还只是当前进程空间中的线性地址</span></span><br><span class="line">	start += get_base(current-&gt;ldt[<span class="number">2</span>]);	<span class="comment">// 此时 start 地址变成系统整个线性空间中的地址</span></span><br><span class="line">	<span class="keyword">while</span> (size&gt;<span class="number">0</span>) &#123;		<span class="comment">// 一页一页地验证</span></span><br><span class="line">		size -= <span class="number">4096</span>;</span><br><span class="line">		write_verify(start);	<span class="comment">// 写页面验证。若页面不可写，则复制页面。</span></span><br><span class="line">		start += <span class="number">4096</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mm/memory.c ---------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_verify</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> page;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取页表目录项，如果该目录项指向的页表不存在，返回</span></span><br><span class="line">	<span class="keyword">if</span> (!( (page = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((address&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>)) )&amp;<span class="number">1</span>))	</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	page &amp;= <span class="number">0xfffff000</span>;	<span class="comment">// 页表地址</span></span><br><span class="line">	page += ((address&gt;&gt;<span class="number">10</span>) &amp; <span class="number">0xffc</span>);		<span class="comment">// 取得线性地址 address 所在的页表项物理地址。页表项地址计算：</span></span><br><span class="line">						<span class="comment">// 1. address = address &gt;&gt; 12</span></span><br><span class="line">						<span class="comment">// 2. 因每个页表项大小为 4 个字节，所以页表项物理地址为 address &lt;&lt; 2</span></span><br><span class="line">						<span class="comment">// 这种做法跟 (address&gt;&gt;10) &amp; 0xffc 是等价的</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">3</span> &amp; *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *) page) == <span class="number">1</span>)  <span class="comment">/* non-writeable, present */</span>	<span class="comment">// 不可写，存在</span></span><br><span class="line">		un_wp_page((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) page);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消写保护页面函数。用于页异常中断过程中写保护异常的处理（写时复制）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un_wp_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> * table_entry)</span>	<span class="comment">// table_entry -&gt; 页表项物理地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> old_page,new_page;</span><br><span class="line"></span><br><span class="line">	old_page = <span class="number">0xfffff000</span> &amp; *table_entry;	<span class="comment">// 取得物理页物理地址</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若页面物理地址大于内存低端，且其在 mem_map 数组中的值为 1（表示仅被引用一次，页面未共享），则在该页面</span></span><br><span class="line">	<span class="comment">// 页表项中置 R/W 标志（可写），并刷新页变换高速缓冲后返回</span></span><br><span class="line">	<span class="keyword">if</span> (old_page &gt;= LOW_MEM &amp;&amp; mem_map[MAP_NR(old_page)]==<span class="number">1</span>) &#123;</span><br><span class="line">		*table_entry |= <span class="number">2</span>;	<span class="comment">// 2 -&gt; 0b11</span></span><br><span class="line">		invalidate();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(new_page=get_free_page()))</span><br><span class="line">		oom();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果原页面物理地址大于内存低端（意味着 mem_map[] &gt; 1，页面是共享的），则将原页面的页面映射值减 1</span></span><br><span class="line">	<span class="keyword">if</span> (old_page &gt;= LOW_MEM)</span><br><span class="line">		mem_map[MAP_NR(old_page)]--;</span><br><span class="line">	*table_entry = new_page | <span class="number">7</span>;	<span class="comment">// 7 -&gt; 0b111</span></span><br><span class="line">	invalidate();</span><br><span class="line">	copy_page(old_page,new_page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy_page(from,to) \</span></span><br><span class="line">__asm__(<span class="string">"cld ; rep ; movsl"</span>::<span class="string">"S"</span> (from),<span class="string">"D"</span> (to),<span class="string">"c"</span> (<span class="number">1024</span>):<span class="string">"cx"</span>,<span class="string">"di"</span>,<span class="string">"si"</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里需要特别强调的是 <code>un_wp_page 函数，它真正体现了“写时复制”的思想</code>。</p>
<h3 id="file-read-函数"><a href="#file-read-函数" class="headerlink" title="file_read 函数"></a><strong>file_read 函数</strong></h3><p>file_read 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/file_dev.c -------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_read</span><span class="params">(struct m_inode * inode, struct file * filp, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left,chars,nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((left=count)&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (left) &#123;</span><br><span class="line">		<span class="comment">// 确定数据块在外设中的位置，并将该数据块读取到缓冲区</span></span><br><span class="line">		<span class="keyword">if</span> (nr = bmap(inode,(filp-&gt;f_pos)/BLOCK_SIZE)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,nr)))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			bh = <span class="literal">NULL</span>;</span><br><span class="line">		nr = filp-&gt;f_pos % BLOCK_SIZE;</span><br><span class="line">		chars = MIN( BLOCK_SIZE-nr , left );</span><br><span class="line">		filp-&gt;f_pos += chars;</span><br><span class="line">		left -= chars;</span><br><span class="line">		<span class="keyword">if</span> (bh) &#123;</span><br><span class="line">			<span class="keyword">char</span> * p = nr + bh-&gt;b_data;</span><br><span class="line">			<span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">				put_fs_byte(*(p++),buf++);	<span class="comment">// 将数据从缓冲区拷贝到进程空间</span></span><br><span class="line">			brelse(bh);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">				put_fs_byte(<span class="number">0</span>,buf++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_atime = CURRENT_TIME;</span><br><span class="line">	<span class="keyword">return</span> (count-left)?(count-left):-ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>重要重要！</strong>在前头 verify_area，我们已经确定了“进程空间线性地址” buf 有对应的物理页面。但在 file_read 函数貌似没有将 buf 转化为真正的物理地址就往 buf 传送数据了：<code>put_fs_byte(*(p++),buf++)</code>。如果真是这种情况，那肯定要出问题。要解决这里的问题，看下边程序解释：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/system_calls.s -----------------------</span></span><br><span class="line">_system_call:</span><br><span class="line">	......</span><br><span class="line">	movl $<span class="number">0x10</span>,%edx		<span class="meta"># set up ds,es to kernel space</span></span><br><span class="line">	mov %dx,%ds</span><br><span class="line">	mov %dx,%es</span><br><span class="line">	movl $<span class="number">0x17</span>,%edx		<span class="meta"># fs points to local data space	# 诀窍就在这一句，我们再看一下</span></span><br><span class="line">								# put_fs_byte 函数的定义就更清楚了</span><br><span class="line">	mov %dx,%fs</span><br><span class="line">	call _sys_call_table(,%eax,<span class="number">4</span>)</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm/segment.h -----------------------</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put_fs_byte</span><span class="params">(<span class="keyword">char</span> val,<span class="keyword">char</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm__ (<span class="string">"movb %0,%%fs:%1"</span>::<span class="string">"r"</span> (val),<span class="string">"m"</span> (*addr));	<span class="comment">// fs 是段选择子，值为 0b10 111，指向的是</span></span><br><span class="line">							<span class="comment">// 进程 LDT 的数据段。它跟 *addr 的组合，唯一确定了进程空间的某一位置 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，我们重点看下 <code>bmap</code> 函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/inode.c ----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bmap</span><span class="params">(struct m_inode * inode,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _bmap(inode,block,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _bmap(struct m_inode * inode,<span class="keyword">int</span> block,<span class="keyword">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (block&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"_bmap: block&lt;0"</span>);</span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">7</span>+<span class="number">512</span>+<span class="number">512</span>*<span class="number">512</span>)</span><br><span class="line">		panic(<span class="string">"_bmap: block&gt;big"</span>);</span><br><span class="line">	<span class="keyword">if</span> (block&lt;<span class="number">7</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[block])</span><br><span class="line">			<span class="keyword">if</span> (inode-&gt;i_zone[block]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">				inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> inode-&gt;i_zone[block];</span><br><span class="line">	&#125;</span><br><span class="line">	block -= <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">if</span> (block&lt;<span class="number">512</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[<span class="number">7</span>])</span><br><span class="line">			<span class="keyword">if</span> (inode-&gt;i_zone[<span class="number">7</span>]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">				inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (!inode-&gt;i_zone[<span class="number">7</span>])</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">7</span>])))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		i = ((<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (bh-&gt;b_data))[block];	<span class="comment">// block 已自减 7 -&gt; block -= 7</span></span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">			<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				((<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (bh-&gt;b_data))[block]=i;</span><br><span class="line">				bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	block -= <span class="number">512</span>;</span><br><span class="line">	<span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[<span class="number">8</span>])</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_zone[<span class="number">8</span>]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">			inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_zone[<span class="number">8</span>])</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">8</span>])))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	i = ((<span class="keyword">unsigned</span> <span class="keyword">short</span> *)bh-&gt;b_data)[block&gt;&gt;<span class="number">9</span>];	</span><br><span class="line">	<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">		<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			((<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (bh-&gt;b_data))[block&gt;&gt;<span class="number">9</span>]=i;</span><br><span class="line">			bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">if</span> (!i)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,i)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	i = ((<span class="keyword">unsigned</span> <span class="keyword">short</span> *)bh-&gt;b_data)[block&amp;<span class="number">511</span>];	<span class="comment">// block 已自减 519 = 7 + 512。</span></span><br><span class="line">							<span class="comment">// 与 511 取与是为了限定 block 值不超过 511。每个逻辑块可以放 512 个逻辑块目录项（1024/2）。</span></span><br><span class="line">	<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">		<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			((<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (bh-&gt;b_data))[block&amp;<span class="number">511</span>]=i;</span><br><span class="line">			bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要看懂 <code>bmap</code> 函数，只需理解 i 节点结构体中的 <code>i_zone[9]</code> 数组。关于该数组详细解释请参考之前博文 <a href="http://xiehongfeng100.github.io/2016/02/29/linux-kenel-0-11-topic-process-one-part4/">Linux 内核学习笔记：进程 1 的创建及执行（第 4 部分）</a>。</p>
<h1 id="新建和写入文件"><a href="#新建和写入文件" class="headerlink" title="新建和写入文件"></a><strong>新建和写入文件</strong></h1><p>新建文件和写入文件实例来自《Linux 内核设计的艺术》：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str1[] = <span class="string">"Hello World"</span>;</span><br><span class="line">	<span class="comment">// 新建文件</span></span><br><span class="line">	<span class="keyword">int</span> fd = creat(<span class="string">"/mnt/user/user1/user2/hello.txt"</span>, <span class="number">0644</span>);</span><br><span class="line">	<span class="comment">// 写入文件</span></span><br><span class="line">	<span class="keyword">int</span> size = write(fd, str1, <span class="built_in">strlen</span>(str1));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a><strong>新建文件</strong></h2><p>新建文件的函数是 creat 函数。creat 函数最终映射到 sys_creat 函数执行。sys_creat 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/open.c -----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sys_open(pathname, O_CREAT | O_TRUNC, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename,<span class="keyword">int</span> flag,<span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i,fd;</span><br><span class="line"></span><br><span class="line">	mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line"></span><br><span class="line">	......	<span class="comment">// 在 filp[20] 和 file_table[64] 申请空闲项，并将 filp[] 挂接到 file_table[]</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">		f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a><strong>查找文件</strong></h3><p>open_namei 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/namei.c ----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> flag, <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">	struct m_inode ** res_inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line">	<span class="keyword">int</span> inr,dev,namelen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>, *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	bh = find_entry(&amp;dir,basename,namelen,&amp;de);	<span class="comment">// 因为是新建文件，在文件“所在”目录找不到该文件的目录项</span></span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;	<span class="comment">// 确定确实要新建文件</span></span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOENT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;	<span class="comment">// 确定对文件“所在”目录有写入权限</span></span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		inode = new_inode(dir-&gt;i_dev);	<span class="comment">// 新建 i 节点</span></span><br><span class="line">		<span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		inode-&gt;i_uid = current-&gt;euid;	<span class="comment">// 这句值得思考: http://xiehongfeng100.github.io/2016/01/29/linux-kenel-0-11-topic-necessary-preparation-part9/</span></span><br><span class="line">		inode-&gt;i_mode = mode;</span><br><span class="line">		inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">		bh = add_entry(dir,basename,namelen,&amp;de);	<span class="comment">// 在文件“所在”目录添加该文件目录项</span></span><br><span class="line">		<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">			inode-&gt;i_nlinks--;</span><br><span class="line">			iput(inode);</span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		de-&gt;inode = inode-&gt;i_num;</span><br><span class="line">		bh-&gt;b_dirt = <span class="number">1</span>;	<span class="comment">// 表示需要同步到外设</span></span><br><span class="line">		brelse(bh);</span><br><span class="line">		iput(dir);</span><br><span class="line">		*res_inode = inode;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="新建-i-节点"><a href="#新建-i-节点" class="headerlink" title="新建 i 节点"></a><strong>新建 i 节点</strong></h3><p>new_inode 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/bitmap.c ---------------------------------</span></span><br><span class="line"><span class="function">struct m_inode * <span class="title">new_inode</span><span class="params">(<span class="keyword">int</span> dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(inode=get_empty_inode()))	<span class="comment">// 在 inode_table[32] 查找一个空闲项</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(sb = get_super(dev)))	<span class="comment">// 获取设备超级块（安装文件系统时已载入）</span></span><br><span class="line">		panic(<span class="string">"new_inode with unknown device"</span>);</span><br><span class="line">	j = <span class="number">8192</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">8</span> ; i++)</span><br><span class="line">		<span class="keyword">if</span> (bh=sb-&gt;s_imap[i])	<span class="comment">// i 节点位图</span></span><br><span class="line">			<span class="keyword">if</span> ((j=find_first_zero(bh-&gt;b_data))&lt;<span class="number">8192</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (!bh || j &gt;= <span class="number">8192</span> || j+i*<span class="number">8192</span> &gt; sb-&gt;s_ninodes) &#123;</span><br><span class="line">		iput(inode);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (set_bit(j,bh-&gt;b_data))</span><br><span class="line">		panic(<span class="string">"new_inode: bit already set"</span>);</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;	<span class="comment">// 表示需要同步到外设</span></span><br><span class="line">	inode-&gt;i_count=<span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_nlinks=<span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_dev=dev;</span><br><span class="line">	inode-&gt;i_uid=current-&gt;euid;	<span class="comment">// 这句值得思考: http://xiehongfeng100.github.io/2016/01/29/linux-kenel-0-11-topic-necessary-preparation-part9/</span></span><br><span class="line">	inode-&gt;i_gid=current-&gt;egid;</span><br><span class="line">	inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_num = j + i*<span class="number">8192</span>;	<span class="comment">// i 节点号</span></span><br><span class="line">	inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 addr 地址开始的 i 节点位图寻找第 1 个 0 值比特位，并将其距离 addr 的比特位偏移值返回</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> find_first_zero(addr) (&#123; \</span></span><br><span class="line"><span class="keyword">int</span> __res; \</span><br><span class="line">__asm__(<span class="string">"cld\n"</span> \</span><br><span class="line">	<span class="string">"1:\tlodsl\n\t"</span> \</span><br><span class="line">	<span class="string">"notl %%eax\n\t"</span> \</span><br><span class="line">	<span class="string">"bsfl %%eax,%%edx\n\t"</span> \</span><br><span class="line">	<span class="string">"je 2f\n\t"</span> \</span><br><span class="line">	<span class="string">"addl %%edx,%%ecx\n\t"</span> \</span><br><span class="line">	<span class="string">"jmp 3f\n"</span> \</span><br><span class="line">	<span class="string">"2:\taddl $32,%%ecx\n\t"</span> \</span><br><span class="line">	<span class="string">"cmpl $8192,%%ecx\n\t"</span> \</span><br><span class="line">	<span class="string">"jl 1b\n"</span> \</span><br><span class="line">	<span class="string">"3:"</span> \</span><br><span class="line">	:<span class="string">"=c"</span> (__res):<span class="string">"c"</span> (<span class="number">0</span>),<span class="string">"S"</span> (addr):<span class="string">"ax"</span>,<span class="string">"dx"</span>,<span class="string">"si"</span>); \</span><br><span class="line">__res;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 置位（置为 1）指定地址开始的第 nr 个位偏移处的比特位，返回原比特位（0 或 1）</span></span><br><span class="line"><span class="comment">// 输入：%0 - eax （返回值）；%1 - eax（0）；%2 - nr，位偏移值；%3 - (addr)，addr 的内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_bit(nr,addr) (&#123;\</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> res __asm__(<span class="string">"ax"</span>); \</span><br><span class="line">__asm__ __volatile__(<span class="string">"btsl %2,%3\n\tsetb %%al"</span>: \</span><br><span class="line"><span class="string">"=a"</span> (res):<span class="string">"0"</span> (<span class="number">0</span>),<span class="string">"r"</span> (nr),<span class="string">"m"</span> (*(addr))); \</span><br><span class="line">res;&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="添加目录项"><a href="#添加目录项" class="headerlink" title="添加目录项"></a><strong>添加目录项</strong></h3><p>add_entry 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/namei.c ----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct buffer_head * <span class="title">add_entry</span><span class="params">(struct m_inode * dir,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="keyword">char</span> * name, <span class="keyword">int</span> namelen, struct dir_entry ** res_dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> block,i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">	*res_dir = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NO_TRUNCATE</span></span><br><span class="line">	<span class="keyword">if</span> (namelen &gt; NAME_LEN)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">if</span> (namelen &gt; NAME_LEN)</span><br><span class="line">		namelen = NAME_LEN;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (!namelen)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(block = dir-&gt;i_zone[<span class="number">0</span>]))	<span class="comment">// 获取目录文件所在第 1 个逻辑块号</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh = bread(dir-&gt;i_dev,block)))	<span class="comment">// 将该逻辑块读入缓冲块</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	de = (struct dir_entry *) bh-&gt;b_data;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;	<span class="comment">// 在目录文件中搜索空闲目录项</span></span><br><span class="line">		<span class="comment">// 如果整个缓冲块都没有空闲，就载入下一个逻辑块继续搜索</span></span><br><span class="line">		<span class="comment">// 全部载入后仍然没有，就在设备上新建逻辑块（磁盘块），用以加载新目录项</span></span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">char</span> *)de &gt;= BLOCK_SIZE+bh-&gt;b_data) &#123;</span><br><span class="line">			brelse(bh);</span><br><span class="line">			bh = <span class="literal">NULL</span>;</span><br><span class="line">			block = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);</span><br><span class="line">			<span class="keyword">if</span> (!block)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> (!(bh = bread(dir-&gt;i_dev,block))) &#123;</span><br><span class="line">				i += DIR_ENTRIES_PER_BLOCK;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			de = (struct dir_entry *) bh-&gt;b_data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 缓冲块的末端找到空闲项</span></span><br><span class="line">		<span class="keyword">if</span> (i*<span class="keyword">sizeof</span>(struct dir_entry) &gt;= dir-&gt;i_size) &#123;</span><br><span class="line">			de-&gt;inode=<span class="number">0</span>;</span><br><span class="line">			dir-&gt;i_size = (i+<span class="number">1</span>)*<span class="keyword">sizeof</span>(struct dir_entry);</span><br><span class="line">			dir-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">			dir-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 加载目录项</span></span><br><span class="line">		<span class="keyword">if</span> (!de-&gt;inode) &#123;</span><br><span class="line">			dir-&gt;i_mtime = CURRENT_TIME;</span><br><span class="line">			<span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; NAME_LEN ; i++)</span><br><span class="line">				de-&gt;name[i]=(i&lt;namelen)?get_fs_byte(name+i):<span class="number">0</span>;</span><br><span class="line">			bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">			*res_dir = de;</span><br><span class="line">			<span class="keyword">return</span> bh;</span><br><span class="line">		&#125;</span><br><span class="line">		de++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>create_block</code> 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/inode.c ----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_block</span><span class="params">(struct m_inode * inode, <span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _bmap(inode,block,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _bmap(struct m_inode * inode,<span class="keyword">int</span> block,<span class="keyword">int</span> create)	<span class="comment">// create = 1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (block&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"_bmap: block&lt;0"</span>);</span><br><span class="line">	<span class="keyword">if</span> (block &gt;= <span class="number">7</span>+<span class="number">512</span>+<span class="number">512</span>*<span class="number">512</span>)</span><br><span class="line">		panic(<span class="string">"_bmap: block&gt;big"</span>);</span><br><span class="line">	<span class="keyword">if</span> (block&lt;<span class="number">7</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[block])</span><br><span class="line">			<span class="keyword">if</span> (inode-&gt;i_zone[block]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">				inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> inode-&gt;i_zone[block];</span><br><span class="line">	&#125;</span><br><span class="line">	block -= <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">if</span> (block&lt;<span class="number">512</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[<span class="number">7</span>])</span><br><span class="line">			<span class="keyword">if</span> (inode-&gt;i_zone[<span class="number">7</span>]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">				inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (!inode-&gt;i_zone[<span class="number">7</span>])</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!(bh = bread(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">7</span>])))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		i = ((<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (bh-&gt;b_data))[block];	<span class="comment">// block 已自减 7 -&gt; block -= 7</span></span><br><span class="line">		<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">			<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">				((<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (bh-&gt;b_data))[block]=i;</span><br><span class="line">				bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	block -= <span class="number">512</span>;</span><br><span class="line">	<span class="keyword">if</span> (create &amp;&amp; !inode-&gt;i_zone[<span class="number">8</span>])</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_zone[<span class="number">8</span>]=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			inode-&gt;i_dirt=<span class="number">1</span>;</span><br><span class="line">			inode-&gt;i_ctime=CURRENT_TIME;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_zone[<span class="number">8</span>])</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">8</span>])))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	i = ((<span class="keyword">unsigned</span> <span class="keyword">short</span> *)bh-&gt;b_data)[block&gt;&gt;<span class="number">9</span>];	</span><br><span class="line">	<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">		<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			((<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (bh-&gt;b_data))[block&gt;&gt;<span class="number">9</span>]=i;</span><br><span class="line">			bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">if</span> (!i)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,i)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	i = ((<span class="keyword">unsigned</span> <span class="keyword">short</span> *)bh-&gt;b_data)[block&amp;<span class="number">511</span>];	<span class="comment">// block 已自减 519 = 7 + 512。</span></span><br><span class="line">							<span class="comment">// 与 511 取与是为了限定 block 值不超过 511。每个逻辑块可以放 512 个逻辑块目录项（1024/2）。</span></span><br><span class="line">	<span class="keyword">if</span> (create &amp;&amp; !i)</span><br><span class="line">		<span class="keyword">if</span> (i=new_block(inode-&gt;i_dev)) &#123;</span><br><span class="line">			((<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (bh-&gt;b_data))[block&amp;<span class="number">511</span>]=i;</span><br><span class="line">			bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fs/bitmap.c ---------------------------------</span></span><br><span class="line"><span class="comment">// 向设备 dev 申请一个逻辑块，返回申请到的逻辑块号</span></span><br><span class="line"><span class="comment">// 并置位该逻辑块在逻辑块位图中对应的比特位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_block</span><span class="params">(<span class="keyword">int</span> dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(sb = get_super(dev)))</span><br><span class="line">		panic(<span class="string">"trying to get new block from nonexistant device"</span>);</span><br><span class="line">	j = <span class="number">8192</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">8</span> ; i++)</span><br><span class="line">		<span class="keyword">if</span> (bh=sb-&gt;s_zmap[i])</span><br><span class="line">			<span class="keyword">if</span> ((j=find_first_zero(bh-&gt;b_data))&lt;<span class="number">8192</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (i&gt;=<span class="number">8</span> || !bh || j&gt;=<span class="number">8192</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (set_bit(j,bh-&gt;b_data))	<span class="comment">// 置位该逻辑块在逻辑块位图中对应的比特位</span></span><br><span class="line">		panic(<span class="string">"new_block: bit already set"</span>);</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	j += i*<span class="number">8192</span> + sb-&gt;s_firstdatazone<span class="number">-1</span>;	<span class="comment">// 逻辑块号</span></span><br><span class="line">	<span class="keyword">if</span> (j &gt;= sb-&gt;s_nzones)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(bh=getblk(dev,j)))	<span class="comment">// 在缓冲区中，为新的逻辑块申请一个空闲缓冲块</span></span><br><span class="line">		panic(<span class="string">"new_block: cannot get block"</span>);</span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_count != <span class="number">1</span>)</span><br><span class="line">		panic(<span class="string">"new block: count is != 1"</span>);</span><br><span class="line">	clear_block(bh-&gt;b_data);	<span class="comment">// 逻辑块清零</span></span><br><span class="line">	bh-&gt;b_uptodate = <span class="number">1</span>;</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a><strong>写入文件</strong></h2><p>《Linux 内核设计的艺术》写文件有一个简要阐述：  </p>
<blockquote>
<p>操作系统对写文件操作的规定是：<code>进程空间的数据先要写入缓冲块中，然后操作系统在适当的条件下，将缓冲区中的数据同步到外设上。</code>而且，操作系统只能以数据块（1KB）为单位，将缓冲区中的缓冲块的数据同步到外设上。这就需要在同步之前，缓冲块与外设上要写入的逻辑块一对一绑定，确定外设上的写入位置，以此保证用户空间写入缓冲块的数据，能够准确地同步到指定逻辑块中。</p>
</blockquote>
<h3 id="调用-sys-write"><a href="#调用-sys-write" class="headerlink" title="调用 sys_write"></a><strong>调用 sys_write</strong></h3><p>write 函数最终映射到 sys_write 函数去执行。sys_write 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/read_write.c -----------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (fd&gt;=NR_OPEN || count &lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (!count)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	inode=file-&gt;f_inode;</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_pipe)	<span class="comment">// 管道文件</span></span><br><span class="line">		<span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">2</span>)?write_pipe(inode,buf,count):-EIO;</span><br><span class="line">	<span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))	<span class="comment">// 字符型文件</span></span><br><span class="line">		<span class="keyword">return</span> rw_char(WRITE,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))	<span class="comment">// 块设备文件</span></span><br><span class="line">		<span class="keyword">return</span> block_write(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line">	<span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))	<span class="comment">// 常规文件</span></span><br><span class="line">		<span class="keyword">return</span> file_write(inode,file,buf,count);</span><br><span class="line">	printk(<span class="string">"(Write)inode-&gt;i_mode=%06o\n\r"</span>,inode-&gt;i_mode);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="调用-file-write"><a href="#调用-file-write" class="headerlink" title="调用 file_write"></a><strong>调用 file_write</strong></h3><p>file_write 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/file_dev.c -------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_write</span><span class="params">(struct m_inode * inode, struct file * filp, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">off_t</span> pos;</span><br><span class="line">	<span class="keyword">int</span> block,c;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">char</span> * p;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ok, append may not work when many processes are writing at the same time</span></span><br><span class="line"><span class="comment"> * but so what. That way leads to madness anyway.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">if</span> (filp-&gt;f_flags &amp; O_APPEND)</span><br><span class="line">		pos = inode-&gt;i_size;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pos = filp-&gt;f_pos;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;count) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(block = create_block(inode,pos/BLOCK_SIZE)))	<span class="comment">// 申请新的数据块</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		c = pos % BLOCK_SIZE;</span><br><span class="line">		p = c + bh-&gt;b_data;</span><br><span class="line">		bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">		c = BLOCK_SIZE-c;</span><br><span class="line">		<span class="keyword">if</span> (c &gt; count-i) c = count-i;</span><br><span class="line">		pos += c;</span><br><span class="line">		<span class="keyword">if</span> (pos &gt; inode-&gt;i_size) &#123;</span><br><span class="line">			inode-&gt;i_size = pos;</span><br><span class="line">			inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i += c;</span><br><span class="line">		<span class="keyword">while</span> (c--&gt;<span class="number">0</span>)</span><br><span class="line">			*(p++) = get_fs_byte(buf++);</span><br><span class="line">		brelse(bh);</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_mtime = CURRENT_TIME;</span><br><span class="line">	<span class="keyword">if</span> (!(filp-&gt;f_flags &amp; O_APPEND)) &#123;</span><br><span class="line">		filp-&gt;f_pos = pos;</span><br><span class="line">		inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (i?i:<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a><strong>数据同步</strong></h3><p><code>数据从缓冲区同步到外设有两种方法。一种是 update 进程定期同步；另一种是因缓冲区使用达到极限，操作系统强行同步。这两种同步方法最终都会调用 sys_sync 函数。</code></p>
<p>第 2 种方法比较隐晦，它是由 <code>getblk</code> 函数完成的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/buffer.c ---------------------------------</span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">getblk</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">tmp</span>, * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">while</span> (bh-&gt;b_dirt) &#123;	<span class="comment">// 缓冲区已无可用缓冲块，需要同步腾空</span></span><br><span class="line">		sync_dev(bh-&gt;b_dev);</span><br><span class="line">		wait_on_buffer(bh);</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_count)</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_sync</code> 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/buffer.c ---------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sync</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先将 i 节点信息写到缓冲区，接下来再由 ll_rw_block 函数将缓冲区数据写到外设</span></span><br><span class="line">	sync_inodes();		<span class="comment">/* write out inodes into buffers */</span>	</span><br><span class="line">	bh = start_buffer;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_BUFFERS ; i++,bh++) &#123;</span><br><span class="line">		wait_on_buffer(bh);</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_dirt)</span><br><span class="line">			ll_rw_block(WRITE,bh);	<span class="comment">// 调用外设请求项函数将数据写到外设</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fs/inode.c ----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync_inodes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line">	inode = <span class="number">0</span>+inode_table;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;NR_INODE ; i++,inode++) &#123;</span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_dirt &amp;&amp; !inode-&gt;i_pipe)</span><br><span class="line">			write_inode(inode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_inode</span><span class="params">(struct m_inode * inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">int</span> block;</span><br><span class="line"></span><br><span class="line">	lock_inode(inode);</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_dirt || !inode-&gt;i_dev) &#123;</span><br><span class="line">		unlock_inode(inode);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(sb=get_super(inode-&gt;i_dev)))</span><br><span class="line">		panic(<span class="string">"trying to write inode without device"</span>);</span><br><span class="line">	block = <span class="number">2</span> + sb-&gt;s_imap_blocks + sb-&gt;s_zmap_blocks +</span><br><span class="line">		(inode-&gt;i_num<span class="number">-1</span>)/INODES_PER_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))</span><br><span class="line">		panic(<span class="string">"unable to read i-node block"</span>);</span><br><span class="line">	((struct d_inode *)bh-&gt;b_data)</span><br><span class="line">		[(inode-&gt;i_num<span class="number">-1</span>)%INODES_PER_BLOCK] =</span><br><span class="line">			*(struct d_inode *)inode;</span><br><span class="line">	bh-&gt;b_dirt=<span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_dirt=<span class="number">0</span>;</span><br><span class="line">	brelse(bh);</span><br><span class="line">	unlock_inode(inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a><strong>修改文件</strong></h1><p><code>修改文件的本质就是可以在文件的任意位置插入、删除数据，且不影响文件已有数据。</code>修改文件需要用到 sys_read、sys_write、sys_lseek 3 个函数。</p>
<p>下边先介绍 sys_lseek 函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/read_write.c ----------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_lseek</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset, <span class="keyword">int</span> origin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= NR_OPEN || !(file=current-&gt;filp[fd]) || !(file-&gt;f_inode)</span><br><span class="line">	   || !IS_SEEKABLE(MAJOR(file-&gt;f_inode-&gt;i_dev)))</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line">	<span class="keyword">if</span> (file-&gt;f_inode-&gt;i_pipe)</span><br><span class="line">		<span class="keyword">return</span> -ESPIPE;</span><br><span class="line">	<span class="keyword">switch</span> (origin) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:	<span class="comment">// 从文件起始处开始偏移</span></span><br><span class="line">			<span class="keyword">if</span> (offset&lt;<span class="number">0</span>) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">			file-&gt;f_pos=offset;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:	<span class="comment">// 从文件的当前读写位置处开始偏移</span></span><br><span class="line">			<span class="keyword">if</span> (file-&gt;f_pos+offset&lt;<span class="number">0</span>) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">			file-&gt;f_pos += offset;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:	<span class="comment">// 从文件的尾端开始偏移</span></span><br><span class="line">			<span class="keyword">if</span> ((tmp=file-&gt;f_inode-&gt;i_size+offset) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			file-&gt;f_pos = tmp;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> file-&gt;f_pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fs/unistd.h --------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEEK_SET	 0	<span class="comment">// 表示从文件起始处开始偏移</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEEK_CUR	 1	<span class="comment">// 表示从文件的当前读写位置处开始偏移</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEEK_END	 2	<span class="comment">// 表示从文件的尾端开始偏移</span></span></span><br></pre></td></tr></table></figure></p>
<p>为了说明修改文件的过程，《Linux 内核设计的艺术》举了一个实例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCATION 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str1[] = <span class="string">"Linux"</span>;</span><br><span class="line">	<span class="keyword">char</span> str2[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> fd, size;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(str2, <span class="number">0</span>, <span class="keyword">sizeof</span>(str2));</span><br><span class="line">	fd = open(<span class="string">"hello.txt"</span>, O_RDWR, <span class="number">0644</span>);	<span class="comment">// hello.txt 文件保存的内容是 "hello,world"</span></span><br><span class="line">	lseek(fd, LOCATION, SEEK_SET);		<span class="comment">// 让文件指针从文件开始处偏移 LOCATION，即令 f_pos = LOCATION</span></span><br><span class="line">	<span class="built_in">strcpy</span>(str2, str1);			<span class="comment">// 将 str1 的内容（包括字符串结束符）复制到 str2</span></span><br><span class="line">	size = read(fd, str2 + <span class="number">5</span>, <span class="number">6</span>);		<span class="comment">// 从文件读取 6 个字节（即 world\0）到 str2 + 5 处（str2 + 5 前是 Linux）</span></span><br><span class="line">	</span><br><span class="line">	lseek(fd, LOCATION, SEEK_SET);		<span class="comment">// 让文件指针指回从文件开始偏移 LOCATION 处，即令 f_pos = LOCATION</span></span><br><span class="line">	size = write(fd, str2, <span class="built_in">strlen</span>(str2));	<span class="comment">// 将 str2 的内容（Linuxworld\0）写回文件</span></span><br><span class="line">	</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上边程序可以看出，修改文件其实就是读文件、写文件的组合。</p>
<h1 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a><strong>关闭文件</strong></h1><p>关闭文件是由 close 函数完成的。close 函数最终映射到 sys_close 函数去执行。sys_close 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/open.c ----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_close</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= NR_OPEN)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line">	<span class="keyword">if</span> (!(filp = current-&gt;filp[fd]))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	current-&gt;filp[fd] = <span class="literal">NULL</span>;	<span class="comment">// 置空</span></span><br><span class="line">	<span class="keyword">if</span> (filp-&gt;f_count == <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"Close: file count is 0"</span>);</span><br><span class="line">	<span class="keyword">if</span> (--filp-&gt;f_count)	<span class="comment">// 引用计数减 1</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	iput(filp-&gt;f_inode);	<span class="comment">// 如果引用计数变为 0，则将该句柄（文件描述符）对应的 inode_table 项释放</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fs/inode.c ----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iput</span><span class="params">(struct m_inode * inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	wait_on_inode(inode);</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_count)</span><br><span class="line">		panic(<span class="string">"iput: trying to free free inode"</span>);</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_pipe) &#123;</span><br><span class="line">		wake_up(&amp;inode-&gt;i_wait);</span><br><span class="line">		<span class="keyword">if</span> (--inode-&gt;i_count)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		free_page(inode-&gt;i_size);</span><br><span class="line">		inode-&gt;i_count=<span class="number">0</span>;</span><br><span class="line">		inode-&gt;i_dirt=<span class="number">0</span>;</span><br><span class="line">		inode-&gt;i_pipe=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_dev) &#123;</span><br><span class="line">		inode-&gt;i_count--;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode)) &#123;</span><br><span class="line">		sync_dev(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">	&#125;</span><br><span class="line">repeat:</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_count&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		inode-&gt;i_count--;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_nlinks) &#123;</span><br><span class="line">		truncate(inode);</span><br><span class="line">		free_inode(inode);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_dirt) &#123;</span><br><span class="line">		write_inode(inode);	<span class="comment">/* we can sleep - so do again */</span></span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_count--;	<span class="comment">// 引用计数减 1</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a><strong>删除文件</strong></h1><p>删除文件的函数是 unlink。unlink 函数最终映射到 sys_unlink 函数执行。</p>
<h2 id="清空目录项"><a href="#清空目录项" class="headerlink" title="清空目录项"></a><strong>清空目录项</strong></h2><p>sys_unlink 函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/namei.c ----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line">	<span class="keyword">int</span> namelen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>, * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(name,&amp;namelen,&amp;basename)))		<span class="comment">// 找到待删文件所在目录的 i 节点</span></span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="keyword">if</span> (!namelen) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;	<span class="comment">// 确认对该目录有写入权限</span></span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	bh = find_entry(&amp;dir,basename,namelen,&amp;de);	<span class="comment">// 将待删文件目录项所在的逻辑块读取到缓冲块</span></span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(inode = iget(dir-&gt;i_dev, de-&gt;inode))) &#123;	<span class="comment">// 取得待删文件的 i 节点</span></span><br><span class="line">		iput(dir);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((dir-&gt;i_mode &amp; S_ISVTX) &amp;&amp; !suser() &amp;&amp;</span><br><span class="line">	    current-&gt;euid != inode-&gt;i_uid &amp;&amp;</span><br><span class="line">	    current-&gt;euid != dir-&gt;i_uid) &#123;</span><br><span class="line">		iput(dir);</span><br><span class="line">		iput(inode);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">		iput(inode);</span><br><span class="line">		iput(dir);</span><br><span class="line">		brelse(bh);</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_nlinks) &#123;</span><br><span class="line">		printk(<span class="string">"Deleting nonexistent file (%04x:%d), %d\n"</span>,</span><br><span class="line">			inode-&gt;i_dev,inode-&gt;i_num,inode-&gt;i_nlinks);</span><br><span class="line">		inode-&gt;i_nlinks=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	de-&gt;inode = <span class="number">0</span>;		<span class="comment">// 将待删文件目录项清空（现在的操作还是在缓冲块，后续调用 write_inode 才真正写到外设）</span></span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;		<span class="comment">// 缓冲块已经修改过</span></span><br><span class="line">	brelse(bh);		<span class="comment">// 将该缓冲块引用计数减 1</span></span><br><span class="line">	inode-&gt;i_nlinks--;	<span class="comment">// 硬链接数减 1</span></span><br><span class="line">	inode-&gt;i_dirt = <span class="number">1</span>;	<span class="comment">// inode 已经修改过（表示需要同步）</span></span><br><span class="line">	inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">	iput(inode);</span><br><span class="line">	iput(dir);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fs/inode.c ----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iput</span><span class="params">(struct m_inode * inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">repeat:</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_count&gt;<span class="number">1</span>) &#123;		<span class="comment">// 如果被引用次数超过 1，则只将引用计数减 1</span></span><br><span class="line">		inode-&gt;i_count--;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_nlinks) &#123;		<span class="comment">// 在这里，我们假设此时 inode-&gt;i_nlinks 已经递减到 0</span></span><br><span class="line">		truncate(inode);	<span class="comment">// 根据 i 节点中的 i_zone[9] 数组，释放文件在外设上占据的逻辑块</span></span><br><span class="line">		free_inode(inode);	<span class="comment">// 将 i 节点位图中对应的位清空，并将 inode_table[32] 中的对应表项清空</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_dirt) &#123;	<span class="comment">// 如果 i 节点（在缓冲块）已经修改过，同步到外设</span></span><br><span class="line">		write_inode(inode);	<span class="comment">/* we can sleep - so do again */</span></span><br><span class="line">		wait_on_inode(inode);</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_count--;	<span class="comment">// 引用计数减 1</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="释放逻辑块"><a href="#释放逻辑块" class="headerlink" title="释放逻辑块"></a><strong>释放逻辑块</strong></h2><p>释放逻辑块调用的函数是 truncate：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/truncate.c -------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">truncate</span><span class="params">(struct m_inode * inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)	</span><br><span class="line">		<span class="keyword">if</span> (inode-&gt;i_zone[i]) &#123;</span><br><span class="line">			free_block(inode-&gt;i_dev,inode-&gt;i_zone[i]);	<span class="comment">// 将 i_zone[9] 前 7 项在逻辑块位图上对应的位清零</span></span><br><span class="line">									<span class="comment">// 但这些“位”对应的逻辑块的数据并没有清零，因为没必要，因为这些块</span></span><br><span class="line">									<span class="comment">// 在被重新利用时，会先被清零，见 new_block 函数</span></span><br><span class="line">			inode-&gt;i_zone[i]=<span class="number">0</span>;		<span class="comment">// i_zone[] 清零</span></span><br><span class="line">		&#125;</span><br><span class="line">	free_ind(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">7</span>]);		<span class="comment">// 一级间接块</span></span><br><span class="line">	free_dind(inode-&gt;i_dev,inode-&gt;i_zone[<span class="number">8</span>]);	<span class="comment">// 二级间接块</span></span><br><span class="line">	inode-&gt;i_zone[<span class="number">7</span>] = inode-&gt;i_zone[<span class="number">8</span>] = <span class="number">0</span>;		<span class="comment">// i_zone[] 清零</span></span><br><span class="line">	inode-&gt;i_size = <span class="number">0</span>;</span><br><span class="line">	inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_ind</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> * p;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!block)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (bh=bread(dev,block)) &#123;</span><br><span class="line">		p = (<span class="keyword">unsigned</span> <span class="keyword">short</span> *) bh-&gt;b_data;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">512</span>;i++,p++)</span><br><span class="line">			<span class="keyword">if</span> (*p)</span><br><span class="line">				free_block(dev,*p);</span><br><span class="line">		brelse(bh);</span><br><span class="line">	&#125;</span><br><span class="line">	free_block(dev,block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_dind</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> * p;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!block)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (bh=bread(dev,block)) &#123;</span><br><span class="line">		p = (<span class="keyword">unsigned</span> <span class="keyword">short</span> *) bh-&gt;b_data;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">512</span>;i++,p++)</span><br><span class="line">			<span class="keyword">if</span> (*p)</span><br><span class="line">				free_ind(dev,*p);</span><br><span class="line">		brelse(bh);</span><br><span class="line">	&#125;</span><br><span class="line">	free_block(dev,block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fs/bitmap.c ---------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_block</span><span class="params">(<span class="keyword">int</span> dev, <span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(sb = get_super(dev)))</span><br><span class="line">		panic(<span class="string">"trying to free block on nonexistent device"</span>);</span><br><span class="line">	<span class="keyword">if</span> (block &lt; sb-&gt;s_firstdatazone || block &gt;= sb-&gt;s_nzones)</span><br><span class="line">		panic(<span class="string">"trying to free block not in datazone"</span>);</span><br><span class="line">	bh = get_hash_table(dev,block);</span><br><span class="line">	<span class="keyword">if</span> (bh) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_count != <span class="number">1</span>) &#123;</span><br><span class="line">			printk(<span class="string">"trying to free block (%04x:%d), count=%d\n"</span>,</span><br><span class="line">				dev,block,bh-&gt;b_count);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		bh-&gt;b_dirt=<span class="number">0</span>;</span><br><span class="line">		bh-&gt;b_uptodate=<span class="number">0</span>;</span><br><span class="line">		brelse(bh);</span><br><span class="line">	&#125;</span><br><span class="line">	block -= sb-&gt;s_firstdatazone - <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (clear_bit(block&amp;<span class="number">8191</span>,sb-&gt;s_zmap[block/<span class="number">8192</span>]-&gt;b_data)) &#123;</span><br><span class="line">		printk(<span class="string">"block (%04x:%d) "</span>,dev,block+sb-&gt;s_firstdatazone<span class="number">-1</span>);</span><br><span class="line">		panic(<span class="string">"free_block: bit already cleared"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sb-&gt;s_zmap[block/<span class="number">8192</span>]-&gt;b_dirt = <span class="number">1</span>;	<span class="comment">// 逻辑块位图所在的某个（block/8192）缓冲块已脏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="释放-i-节点"><a href="#释放-i-节点" class="headerlink" title="释放 i 节点"></a><strong>释放 i 节点</strong></h2><p>释放 i 节点调用的函数是 free_inode：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/bitmap.c ---------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_inode</span><span class="params">(struct m_inode * inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (!inode-&gt;i_dev) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(inode,<span class="number">0</span>,<span class="keyword">sizeof</span>(*inode));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_count&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		printk(<span class="string">"trying to free inode with count=%d\n"</span>,inode-&gt;i_count);</span><br><span class="line">		panic(<span class="string">"free_inode"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_nlinks)</span><br><span class="line">		panic(<span class="string">"trying to free inode with links"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!(sb = get_super(inode-&gt;i_dev)))	<span class="comment">// 获取超级块</span></span><br><span class="line">		panic(<span class="string">"trying to free inode on nonexistent device"</span>);</span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_num &lt; <span class="number">1</span> || inode-&gt;i_num &gt; sb-&gt;s_ninodes)</span><br><span class="line">		panic(<span class="string">"trying to free inode 0 or nonexistant inode"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!(bh=sb-&gt;s_imap[inode-&gt;i_num&gt;&gt;<span class="number">13</span>]))	<span class="comment">// 获取 i 节点所在的缓冲块</span></span><br><span class="line">		panic(<span class="string">"nonexistent imap in superblock"</span>);</span><br><span class="line">	<span class="keyword">if</span> (clear_bit(inode-&gt;i_num&amp;<span class="number">8191</span>,bh-&gt;b_data))	<span class="comment">// 清零 i 节点位图与该 i 节点对应的位</span></span><br><span class="line">		printk(<span class="string">"free_inode: bit already cleared.\n\r"</span>);</span><br><span class="line">	bh-&gt;b_dirt = <span class="number">1</span>;	<span class="comment">// 缓冲块数据已脏（表示需要同步）</span></span><br><span class="line">	<span class="built_in">memset</span>(inode,<span class="number">0</span>,<span class="keyword">sizeof</span>(*inode));	<span class="comment">// 将该 i 节点在 inode_table[] 的表项清零</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/10/linux-kenel-0-11-topic-buffer/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Linux 内核学习笔记：缓冲区
        
      </div>
    </a>
  
  
    <a href="/2016/03/05/linux-kenel-0-11-topic-process-two-part3/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Linux 内核学习笔记：进程 2 的创建及执行（第 3 部分） —— 重建 shell 进程</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>







      <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>

<script>
var gitalk = new Gitalk({
  clientID: '64c19d7f57bebbb343c4',
  clientSecret: '287daeba39e73fdde92f24540c9f3c0fd5238512',
  repo: 'BlogComments',
  owner: 'xiemax100',
  admin: ['xiemax100'],
  id: md5(window.location.pathname),
  distractionFreeMode: true
})

gitalk.render('gitalk-container')
</script>






    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#安装文件系统"><span class="toc-number">1.</span> <span class="toc-text">安装文件系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#打开和读取文件"><span class="toc-number">2.</span> <span class="toc-text">打开和读取文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#打开文件"><span class="toc-number">2.1.</span> <span class="toc-text">打开文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读取文件"><span class="toc-number">2.2.</span> <span class="toc-text">读取文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#verify-area-函数"><span class="toc-number">2.2.1.</span> <span class="toc-text">verify_area 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file-read-函数"><span class="toc-number">2.2.2.</span> <span class="toc-text">file_read 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#新建和写入文件"><span class="toc-number">3.</span> <span class="toc-text">新建和写入文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#新建文件"><span class="toc-number">3.1.</span> <span class="toc-text">新建文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查找文件"><span class="toc-number">3.1.1.</span> <span class="toc-text">查找文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新建-i-节点"><span class="toc-number">3.1.2.</span> <span class="toc-text">新建 i 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加目录项"><span class="toc-number">3.1.3.</span> <span class="toc-text">添加目录项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写入文件"><span class="toc-number">3.2.</span> <span class="toc-text">写入文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-sys-write"><span class="toc-number">3.2.1.</span> <span class="toc-text">调用 sys_write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-file-write"><span class="toc-number">3.2.2.</span> <span class="toc-text">调用 file_write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据同步"><span class="toc-number">3.2.3.</span> <span class="toc-text">数据同步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#修改文件"><span class="toc-number">4.</span> <span class="toc-text">修改文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关闭文件"><span class="toc-number">5.</span> <span class="toc-text">关闭文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#删除文件"><span class="toc-number">6.</span> <span class="toc-text">删除文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#清空目录项"><span class="toc-number">6.1.</span> <span class="toc-text">清空目录项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#释放逻辑块"><span class="toc-number">6.2.</span> <span class="toc-text">释放逻辑块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#释放-i-节点"><span class="toc-number">6.3.</span> <span class="toc-text">释放 i 节点</span></a></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var toc_button = document.getElementById("tocButton");
    var toc_div = document.getElementById("toc");
    toc_button.onclick=function() {
        if (toc_div.style.display == "none") {
            toc_div.style.display = "block";
            toc_button.value = "隐藏目录";
            document.getElementById("switch-btn").style.display = "none";
            document.getElementById("switch-area").style.display = "none";
        }
        else {
            toc_div.style.display = "none";
            toc_button.value = "显示目录";
            document.getElementById("switch-btn").style.display = "block";
            document.getElementById("switch-area").style.display = "block";
        }
    }

    if ($(".toc").length < 1) {
        $("#toc").css("display","none");
        $("#tocButton").css("display","none");
        $(".switch-btn").css("display","block");
        $(".switch-area").css("display","block");
    }
</script>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 Max
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>